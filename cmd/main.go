package main

import (
	"fmt"
	"log"
	"os"
	"runtime/pprof"

	"github.com/leyrem/docker-vulnerability-analyzer/scanners"
	"github.com/urfave/cli/v2"
)

func addStartFlag(flags []cli.Flag, required bool) []cli.Flag {
	return append(flags, &cli.IntFlag{
		Name:     "start",
		Aliases:  []string{"s"},
		Required: required,
		Value:    0,
		Usage:    "Start block/ledger index",
	})
}

func addEndFlag(flags []cli.Flag, required bool) []cli.Flag {
	return append(flags, &cli.IntFlag{
		Name:     "end",
		Aliases:  []string{"e"},
		Required: required,
		Value:    0,
		Usage:    "End block/ledger index",
	})
}

func addOutputFlag(flags []cli.Flag) []cli.Flag {
	return append(flags, &cli.StringFlag{
		Name:     "output",
		Aliases:  []string{"o"},
		Usage:    "Base output filepath for generated vulnerability report files",
		Required: true,
	})
}

func addImageFlag(flags []cli.Flag) []cli.Flag {
	return append(flags, &cli.StringFlag{
		Name:     "image",
		Aliases:  []string{"i"},
		Usage:    "Name (and tag) of the Docker image to analyze. Note that the format must be --> image:tag",
		Required: true,
	})
}

func addConfigFlag(flags []cli.Flag) []cli.Flag {
	return append(flags, &cli.StringFlag{
		Name:     "config",
		Aliases:  []string{"c"},
		Usage:    "Configuration file",
		Required: true,
	})
}

func addActionPropertyFlag(flags []cli.Flag) []cli.Flag {
	return append(flags, &cli.StringFlag{
		Name:  "by",
		Value: "name",
		Usage: "Property to group the actions by",
	})
}

func addRangeFlags(flags []cli.Flag, required bool) []cli.Flag {
	return addStartFlag(addEndFlag(flags, required), required)
}

func addFetchFlags(flags []cli.Flag) []cli.Flag {
	return addRangeFlags(addOutputFlag(flags), true)
}

func addPatternFlag(flags []cli.Flag) []cli.Flag {
	return append(flags, &cli.StringFlag{
		Name:     "pattern",
		Aliases:  []string{"p"},
		Value:    "",
		Usage:    "Patterns of files to check",
		Required: true,
	})
}

func addGroupDurationFlag(flags []cli.Flag) []cli.Flag {
	return append(flags, &cli.StringFlag{
		Name:    "duration",
		Aliases: []string{"d"},
		Value:   "6h",
		Usage:   "Duration to group by when counting",
	})
}

func addCpuProfileFlag(flags []cli.Flag) []cli.Flag {
	return append(flags, &cli.StringFlag{
		Name:     "cpu-profile",
		Usage:    "Path where to store the CPU profile",
		Value:    "",
		Required: false,
	})
}

func makeAction(f func(*cli.Context) error) func(*cli.Context) error {
	return func(c *cli.Context) error {
		cpuProfile := c.String("cpu-profile")
		if cpuProfile != "" {
			f, err := os.Create(cpuProfile)
			if err != nil {
				return fmt.Errorf("could not create CPU profile: %s", err.Error())
			}
			defer f.Close()
			if err := pprof.StartCPUProfile(f); err != nil {
				return fmt.Errorf("could not start CPU profile: %s", err.Error())
			}
			defer pprof.StopCPUProfile()
		}

		return f(c)
	}
}

var scanCommands []*cli.Command = []*cli.Command{
	{
		Name:  "all-scan",
		Flags: addImageFlag(addOutputFlag(nil)),
		Usage: "Scans the given Docker image using all available scanners",
		Action: makeAction(func(c *cli.Context) error {
			return scanners.UseAllScanners(c.String("image"), c.String("output"))
		}),
	},
	/*{
		Name:  "count-messages",
		Flags: addPatternFlag(addRangeFlags(nil, false)),
		Usage: "Count the number of messages in the data",
		Action: makeAction(func(c *cli.Context) error {
			count, err := processor.CountTransactions(
				iota.New(), c.String("pattern"),
				c.Uint64("start"), c.Uint64("end"))
			if err != nil {
				return err
			}
			fmt.Printf("found %d messages\n", count)
			return nil
		}),
	},
	{
		Name:  "average-number-messages-per-block",
		Flags: addPatternFlag(addRangeFlags(nil, false)),
		Usage: "Compute the average number of messages (i.e. the number of messages referenced by each milestone) per block in the data",
		Action: makeAction(func(c *cli.Context) error {
			count, err := processor.AvegareMessagesPerBlock(
				iota.New(), c.String("pattern"),
				c.Uint64("start"), c.Uint64("end"))
			if err != nil {
				return err
			}
			fmt.Printf("The average number of messages per block is %d \n", count)
			return nil
		}),
	},
	{
		Name:  "average-number-messages-per-block-over-time",
		Flags: addGroupDurationFlag(addPatternFlag(addOutputFlag(addRangeFlags(nil, false)))),
		Usage: "iota specific: Compute the average number of messages (i.e. the number of messages referenced by each milestone) per block in the data over time",
		Action: makeAction(func(c *cli.Context) error {
			duration, err := time.ParseDuration(c.String("duration"))
			if err != nil {
				return err
			}
			counts, err := processor.AvegareMessagesPerBlockOverTime(
				iota.New(), c.String("pattern"),
				c.Uint64("start"), c.Uint64("end"), duration)
			if err != nil {
				return err
			}
			return core.Persist(counts, c.String("output"))
		}),
	},
	{
		Name:  "count-messages-over-time",
		Flags: addGroupDurationFlag(addPatternFlag(addOutputFlag(addRangeFlags(nil, false)))),
		Usage: "Count number of messages over time in the data",
		Action: makeAction(func(c *cli.Context) error {
			duration, err := time.ParseDuration(c.String("duration"))
			if err != nil {
				return err
			}
			counts, err := processor.CountTransactionsOverTime(
				iota.New(), c.String("pattern"),
				c.Uint64("start"), c.Uint64("end"), duration)
			if err != nil {
				return err
			}
			return core.Persist(counts, c.String("output"))
		}),
	},
	{
		Name:  "count-empty-blocks",
		Flags: addPatternFlag(addRangeFlags(nil, false)),
		Usage: "iota specific: Count the number of empty blocks in the data, i.e. blocks with no messages",
		Action: makeAction(func(c *cli.Context) error {
			count, err := processor.CountEmptyBlocks(
				iota.New(), c.String("pattern"),
				c.Uint64("start"), c.Uint64("end"))
			if err != nil {
				return err
			}
			fmt.Printf("found %d empty blocks\n", count)
			return nil
		}),
	},
	{
		Name:  "count-empty-blocks-over-time",
		Flags: addGroupDurationFlag(addPatternFlag(addOutputFlag(addRangeFlags(nil, false)))),
		Usage: "iota specific: Count number of empty blocks (i.e. blocks with no messages) over time in the data",
		Action: makeAction(func(c *cli.Context) error {
			duration, err := time.ParseDuration(c.String("duration"))
			if err != nil {
				return err
			}
			counts, err := processor.CountEmptyBlocksOverTime(
				iota.New(), c.String("pattern"),
				c.Uint64("start"), c.Uint64("end"), duration)
			if err != nil {
				return err
			}
			return core.Persist(counts, c.String("output"))
		}),
	},
	{
		Name:  "count-indexation-payload",
		Flags: addPatternFlag(addRangeFlags(nil, false)),
		Usage: "Count the number of messages in the data which have an indexation payload",
		Action: makeAction(func(c *cli.Context) error {
			fmt.Println("pp: ", c.String("pattern"))
			count, err := processor.CountIndexationPayload(
				iota.New(), c.String("pattern"),
				c.Uint64("start"), c.Uint64("end"))
			if err != nil {
				return err
			}
			fmt.Printf("found %d messages with indexation payload\n", count)
			return nil
		}),
	},
	{
		Name:  "count-indexation-payload-over-time",
		Flags: addGroupDurationFlag(addPatternFlag(addOutputFlag(addRangeFlags(nil, false)))),
		Usage: "iota specific: Count number of messages with indexation payload over time in the data",
		Action: makeAction(func(c *cli.Context) error {
			duration, err := time.ParseDuration(c.String("duration"))
			if err != nil {
				return err
			}
			counts, err := processor.CountIndexationPayloadOverTime(
				iota.New(), c.String("pattern"),
				c.Uint64("start"), c.Uint64("end"), duration)
			if err != nil {
				return err
			}
			return core.Persist(counts, c.String("output"))
		}),
	},
	{
		Name:  "count-signed-transaction-payload",
		Flags: addPatternFlag(addRangeFlags(nil, false)),
		Usage: "Count the number of messages in the data which have a signed transaction payload",
		Action: makeAction(func(c *cli.Context) error {
			count, err := processor.CountSignedTransactionPayload(
				iota.New(), c.String("pattern"),
				c.Uint64("start"), c.Uint64("end"))
			if err != nil {
				return err
			}
			fmt.Printf("found %d messages with signed transaction payload\n", count)
			return nil
		}),
	},
	{
		Name:  "count-signed-transaction-payload-over-time",
		Flags: addGroupDurationFlag(addPatternFlag(addOutputFlag(addRangeFlags(nil, false)))),
		Usage: "iota specific: Count number of messages with signed transaction payload over time in the data",
		Action: makeAction(func(c *cli.Context) error {
			duration, err := time.ParseDuration(c.String("duration"))
			if err != nil {
				return err
			}
			counts, err := processor.CountSgnTransactionPayloadOverTime(
				iota.New(), c.String("pattern"),
				c.Uint64("start"), c.Uint64("end"), duration)
			if err != nil {
				return err
			}
			return core.Persist(counts, c.String("output"))
		}),
	},
	{
		Name:  "count-no-payload",
		Flags: addPatternFlag(addRangeFlags(nil, false)),
		Usage: "Count the number of messages in the data which have a no payload",
		Action: makeAction(func(c *cli.Context) error {
			count, err := processor.CountNoPayload(
				iota.New(), c.String("pattern"),
				c.Uint64("start"), c.Uint64("end"))
			if err != nil {
				return err
			}
			fmt.Printf("found %d messages with no payload\n", count)
			return nil
		}),
	},
	{
		Name:  "count-no-payload-over-time",
		Flags: addGroupDurationFlag(addPatternFlag(addOutputFlag(addRangeFlags(nil, false)))),
		Usage: "iota specific: Count number of messages with no payload over time in the data",
		Action: makeAction(func(c *cli.Context) error {
			duration, err := time.ParseDuration(c.String("duration"))
			if err != nil {
				return err
			}
			counts, err := processor.CountNoPayloadOverTime(
				iota.New(), c.String("pattern"),
				c.Uint64("start"), c.Uint64("end"), duration)
			if err != nil {
				return err
			}
			return core.Persist(counts, c.String("output"))
		}),
	},
	{
		Name:  "count-other-payload",
		Flags: addPatternFlag(addRangeFlags(nil, false)),
		Usage: "Count the number of messages in the data which have a payload other than 0,1,2",
		Action: makeAction(func(c *cli.Context) error {
			count, err := processor.CountOtherPayload(
				iota.New(), c.String("pattern"),
				c.Uint64("start"), c.Uint64("end"))
			if err != nil {
				return err
			}
			fmt.Printf("found %d messages with other payload\n", count)
			return nil
		}),
	},
	{
		Name:  "count-conflicts",
		Flags: addPatternFlag(addRangeFlags(nil, false)),
		Usage: "Count the number of messages in the data which have a transaction marked as conflicting",
		Action: makeAction(func(c *cli.Context) error {
			count, err := processor.CountConflicting(
				iota.New(), c.String("pattern"),
				c.Uint64("start"), c.Uint64("end"))
			if err != nil {
				return err
			}
			fmt.Printf("found %d messages with conflicting transactions\n", count)
			return nil
		}),
	},
	{
		Name:  "count-conflicts-over-time",
		Flags: addGroupDurationFlag(addPatternFlag(addOutputFlag(addRangeFlags(nil, false)))),
		Usage: "iota specific: Count number of messages which have a transaction marked as conflicting over time in the data",
		Action: makeAction(func(c *cli.Context) error {
			duration, err := time.ParseDuration(c.String("duration"))
			if err != nil {
				return err
			}
			counts, err := processor.CountConflictingOverTime(
				iota.New(), c.String("pattern"),
				c.Uint64("start"), c.Uint64("end"), duration)
			if err != nil {
				return err
			}
			return core.Persist(counts, c.String("output"))
		}),
	},
	{
		Name:  "group-conflicts",
		Flags: addPatternFlag(addOutputFlag(addRangeFlags(nil, false))),
		Usage: "Count and group the number of messages in the data which have a transaction marked as conflicting per conflict type",
		Action: makeAction(func(c *cli.Context) error {
			counts, err := processor.GroupConflicting(
				iota.New(), c.String("pattern"),
				c.Uint64("start"), c.Uint64("end"))
			if err != nil {
				return err
			}
			return core.Persist(counts, c.String("output"))
		}),
	},
	{
		Name:  "group-by-index",
		Flags: addPatternFlag(addOutputFlag(addRangeFlags(nil, false))),
		Usage: "Count and group the number of messages in the data which have indexation payload per index",
		Action: makeAction(func(c *cli.Context) error {
			counts, err := processor.GroupByIndex(
				iota.New(), c.String("pattern"),
				c.Uint64("start"), c.Uint64("end"))
			if err != nil {
				return err
			}
			return core.Persist(counts, c.String("output"))
		}),
	},
	{
		Name:  "group-by-index-over-time",
		Flags: addGroupDurationFlag(addPatternFlag(addOutputFlag(addRangeFlags(nil, false)))),
		Usage: "Count and group the number of messages in the data which have indexation payload per index over time",
		Action: makeAction(func(c *cli.Context) error {
			duration, err := time.ParseDuration(c.String("duration"))
			if err != nil {
				return err
			}
			counts, err := processor.GroupByIndexOverTime(
				iota.New(), c.String("pattern"),
				c.Uint64("start"), c.Uint64("end"), duration)
			if err != nil {
				return err
			}
			return core.Persist(counts, c.String("output"))
		}),
	},
	{
		Name:  "group-by-output-address",
		Flags: addPatternFlag(addOutputFlag(addRangeFlags(nil, false))),
		Usage: "Count and group the number of messages in the data which have transaction payload per outputs address",
		Action: makeAction(func(c *cli.Context) error {
			counts, err := processor.GroupByAddress(
				iota.New(), c.String("pattern"),
				c.Uint64("start"), c.Uint64("end"))
			if err != nil {
				return err
			}
			return core.Persist(counts, c.String("output"))
		}),
	},
	{
		Name:  "average-value-spent-transaction",
		Flags: addPatternFlag(addRangeFlags(nil, false)),
		Usage: "Returns the average value spent per transaction after computing the mean among all value transactions",
		Action: makeAction(func(c *cli.Context) error {
			count, err := processor.AvegareValueTransactions(
				iota.New(), c.String("pattern"),
				c.Uint64("start"), c.Uint64("end"))
			if err != nil {
				return err
			}
			fmt.Printf("The average value spent in a transaction is: %f \n", count)
			return nil
		}),
	},
	{
		Name:  "average-value-spent-transaction-over-time",
		Flags: addGroupDurationFlag(addPatternFlag(addOutputFlag(addRangeFlags(nil, false)))),
		Usage: "Returns the average value spent per transaction after computing the mean among all value transactions over time",
		Action: makeAction(func(c *cli.Context) error {
			duration, err := time.ParseDuration(c.String("duration"))
			if err != nil {
				return err
			}
			counts, err := processor.AvegareValueTransactionsOverTime(
				iota.New(), c.String("pattern"),
				c.Uint64("start"), c.Uint64("end"), duration)
			if err != nil {
				return err
			}
			return core.Persist(counts, c.String("output"))
		}),
	},
	{
		Name:  "average-time-between-milestones",
		Flags: addPatternFlag(addRangeFlags(nil, false)),
		Usage: "Returns the average time between the issuing of two consecutive milestones",
		Action: makeAction(func(c *cli.Context) error {
			count, err := processor.AvegareTimeMilestones(
				iota.New(), c.String("pattern"),
				c.Uint64("start"), c.Uint64("end"))
			if err != nil {
				return err
			}
			fmt.Printf("The average time between issued consecutive milestones is: %f \n", count)
			return nil
		}),
	},
	{
		Name:  "average-time-between-milestones-over-time",
		Flags: addGroupDurationFlag(addPatternFlag(addOutputFlag(addRangeFlags(nil, false)))),
		Usage: "Returns the average time between the issuing of two consecutive milestones over time",
		Action: makeAction(func(c *cli.Context) error {
			duration, err := time.ParseDuration(c.String("duration"))
			if err != nil {
				return err
			}

			count, err := processor.AvegareTimeMilestonesOverTime(
				iota.New(), c.String("pattern"),
				c.Uint64("start"), c.Uint64("end"), duration)
			if err != nil {
				return err
			}
			return core.Persist(count, c.String("output"))
		}),
	},
	{
		Name:  "group-signed-transactions-by-index",
		Flags: addPatternFlag(addOutputFlag(addRangeFlags(nil, false))),
		Usage: "Count and group the number of messages in the data with a signed transaction payload by index",
		Action: makeAction(func(c *cli.Context) error {
			counts, err := processor.GroupSgndTransactionsByIndex(
				iota.New(), c.String("pattern"),
				c.Uint64("start"), c.Uint64("end"))
			if err != nil {
				return err
			}
			return core.Persist(counts, c.String("output"))
		}),
	},*/
}

func main() {
	app := &cli.App{
		Usage: "Tool to fetch and analyze docker image vulnerabilities",
		Flags: addCpuProfileFlag(nil),
		Commands: []*cli.Command{
			{
				Name:        "scan",
				Usage:       "Scan Docker images",
				Subcommands: scanCommands,
			},
		},
	}

	err := app.Run(os.Args)
	if err != nil {
		log.Fatal(err)
	}
}
