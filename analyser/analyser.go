package analyser

import (
	"encoding/json"
	"fmt"
	"log"
	"math"
	"os"
	"path/filepath"
	"strings"
	"sync"

	"github.com/leyrem/docker-vulnerability-analyzer/outputdata"
	"github.com/leyrem/docker-vulnerability-analyzer/scanners"
	"github.com/leyrem/docker-vulnerability-analyzer/utils"
)

func writeDataToFile(data outputdata.OutCVEs, outFileName string) error {
	// Marshal the struct to JSON
	jsonData, err := json.MarshalIndent(data, "", "  ")
	if err != nil {
		return fmt.Errorf("error marshalling JSON file: %v \n", err)
	}

	// Write the JSON data to a file
	file, err := os.Create(outFileName)
	if err != nil {
		return fmt.Errorf("error creating output file %s for JSON: %v", outFileName, err)
	}
	defer file.Close()

	_, err = file.Write(jsonData)
	if err != nil {
		return fmt.Errorf("error writing JSON data to file: %v", err)
	}

	log.Printf("JSON data list of CVEs succesfully written out to file %s", outFileName)
	return nil
}

func GetListCVEsAllScanners(sourceDir string, imageName string, outputFilepath string) error {

	patternSearchImages := "*_scan_" + imageName + "_2024*"
	searchPattern := filepath.Join(sourceDir, patternSearchImages)

	files, err := filepath.Glob(searchPattern)
	if err != nil {
		return err
	}
	log.Printf("Found %d report files for image %s \n", len(files), imageName)

	workersCount := len(files)
	var wg sync.WaitGroup
	wg.Add(workersCount)
	resultsErr := make(chan error, workersCount)
	resultsData := make(chan *outputdata.GetListCVEsAllScannersRes, workersCount)
	pairs := make(map[string]string)
	writeData := outputdata.OutCVEs{}

	scannerNames := []string{}
	for _, filename := range files {
		parts := strings.Split(filename, "_")
		p := parts[0]
		parts = strings.Split(p, "/")
		nameScanner := parts[len(parts)-1]
		scannerNames = append(scannerNames, nameScanner)

		pairs[nameScanner] = filename
	}
	scannersObj := scanners.InstantiateGivenScanners(scannerNames)

	if len(scannersObj) == 0 {
		return fmt.Errorf("no scanners were specified to be used")
	}

	for _, s := range scannersObj {
		go s.GetListCVEs(&wg, resultsErr, resultsData, pairs[s.Name])
	}

	// Wait for all scanners to finish
	go func() {
		wg.Wait()
		close(resultsErr)
		close(resultsData)
	}()

	var finalErr error

	// Process results
	for r := range resultsErr {
		if r != nil {
			finalErr = fmt.Errorf("%v \n NEW ERROR: %v", finalErr, r)
		}
	}

	if finalErr != nil {
		return finalErr
	}

	for d := range resultsData {
		writeData.CVEsDetected = append(writeData.CVEsDetected, d)
	}

	vals := getListUniqueCVEs(writeData.CVEsDetected)
	writeData.UniqueCVEs = vals
	writeData.NumUniqueCVEs = len(vals)
	writeData.ImageScanned = imageName

	for _, d := range writeData.CVEsDetected {
		val := float32(d.NumCVEs) / float32(writeData.NumUniqueCVEs)
		if !math.IsNaN(float64(val)) {
			d.RelativeEfficiency = val
		}
	}

	err = writeDataToFile(writeData, outputFilepath)
	if err != nil {
		return err
	}
	return nil
}

func getListUniqueCVEs(resultsScans []*outputdata.GetListCVEsAllScannersRes) []*outputdata.UnifiedCVEInfo {
	seen := make(map[string]bool)

	uniques := make(map[string]*outputdata.UnifiedCVEInfo)

	for _, scannerRes := range resultsScans {
		for _, cve := range scannerRes.CVEs {
			if !seen[cve.CVE_ID] {
				info := &outputdata.UnifiedCVEInfo{
					CVE_ID: cve.CVE_ID,
					ScannerCVEInfo: []outputdata.ScannerCVE{
						outputdata.ScannerCVE{
							ScannerName: scannerRes.ScannerName,
							CVEInfo:     cve,
						},
					},
				}
				uniques[cve.CVE_ID] = info
			} else {
				el := uniques[cve.CVE_ID]
				el.ScannerCVEInfo = append(el.ScannerCVEInfo, outputdata.ScannerCVE{
					ScannerName: scannerRes.ScannerName,
					CVEInfo:     cve,
				})
				uniques[cve.CVE_ID] = el
			}
			seen[cve.CVE_ID] = true
		}
	}
	vals := utils.GetCVEScannerValues(uniques)
	for _, a := range vals {
		a.DetectionRate = len(a.ScannerCVEInfo)
	}
	return vals
}
