package utils

import (
	"encoding/csv"
	"fmt"
	"io"
	"log"
	"os"
	"regexp"
	"strings"

	"github.com/leyrem/docker-vulnerability-analyzer/outputdata"
)

func ReadCSV(fileName string, typeE string) ([]string, error) {
	// Open the CSV file
	file, err := os.Open(fileName)

	if err != nil {
		log.Printf("error opening CSV file %s: %v\n", fileName, err)
		return []string{}, fmt.Errorf("error opening CSV file %s: %v \n", fileName, err)
	}
	defer file.Close()

	// Create a new CSV reader
	reader := csv.NewReader(file)

	var imagesToDownload []string

	// Read the file line by line
	for {
		// Read a single line from the file
		record, err := reader.Read()
		// Check for end of file
		if err != nil {
			// If end of file is reached, break the loop

			if err == io.EOF {
				// If end of file is reached, break the loop
				break
			}
			log.Printf("error reading CSV file %s: %v \n", fileName, err)
			return []string{}, fmt.Errorf("error reading CSV file %s: %v \n", fileName, err)
		}

		var completeName string

		if typeE == "official" {
			completeName = record[0] + ":" + record[3]
		} else {
			completeName = record[1] + "/" + record[0] + ":" + record[3]
		}
		imagesToDownload = append(imagesToDownload, completeName)
	}
	return imagesToDownload, nil
}

func containsLinear(arr []string, target string) bool {
	for _, v := range arr {
		if v == target {
			return true
		}
	}
	return false
}

func HasDuplicates(cs []outputdata.CVE) ([]string, []outputdata.CVE) {
	dups := []string{}
	seen := make(map[string]bool)
	for _, c := range cs {
		str := c.CVE_ID
		if seen[str] {
			if !containsLinear(dups, str) {
				dups = append(dups, str)
			}
		}
		seen[str] = true
	}

	noDups := make(map[string]outputdata.CVE)

	for _, c := range cs {
		if value, exists := noDups[c.CVE_ID]; exists {
			value.Packages = append(value.Packages, c.Packages...)
			noDups[c.CVE_ID] = value
		} else {
			noDups[c.CVE_ID] = outputdata.CVE{
				CVE_ID:       c.CVE_ID,
				CVSSV3_Score: c.CVSSV3_Score,
				Severity:     c.Severity,
				Packages:     c.Packages,
				Type:         c.Type,
				IsFixed:      c.IsFixed,
				FixedVersion: c.FixedVersion,
			}
		}
	}

	res := getCVEValues(noDups)

	return dups, res

}

// getCVEValues extracts the values from the map and returns them as a slice
func getCVEValues(cveMap map[string]outputdata.CVE) []outputdata.CVE {
	cveList := make([]outputdata.CVE, 0, len(cveMap))
	for _, value := range cveMap {
		cveList = append(cveList, value)
	}
	return cveList
}

func GetCVEScannerValues(cveMap map[string]*outputdata.UnifiedCVEInfo) []*outputdata.UnifiedCVEInfo {
	cveList := make([]*outputdata.UnifiedCVEInfo, 0, len(cveMap))
	for _, value := range cveMap {
		cveList = append(cveList, value)
	}
	return cveList
}

func ExtractSeverityValueTrivy(input string) string {
	// Split the input string by newline
	lines := strings.Split(input, "\n")

	// Iterate through each line
	for _, line := range lines {
		if strings.HasPrefix(line, "Severity:") {
			// Split the line by ": " to separate the key and the value
			parts := strings.SplitN(line, ": ", 2)
			if len(parts) == 2 {
				return parts[1]
			}
		}
	}
	return "" // Return an empty string if "Severity:" is not found or improperly formatted
}

func ExtractFixValueGrype(input string) string {
	// Split the input string by newline
	lines := strings.Split(input, "\n")

	// Iterate through each line
	for _, line := range lines {
		if strings.HasPrefix(line, "Fix Version:") {
			// Split the line by ": " to separate the key and the value
			parts := strings.SplitN(line, ": ", 2)
			if len(parts) == 2 {
				return parts[1]
			}
		}
	}
	return "" // Return an empty string if "Severity:" is not found or improperly formatted
}

func ExtractTypeValueGrype(input string) string {
	// Split the input string by newline
	lines := strings.Split(input, "\n")

	// Iterate through each line
	for _, line := range lines {
		if strings.HasPrefix(line, "Type:") {
			// Split the line by ": " to separate the key and the value
			parts := strings.SplitN(line, ": ", 2)
			if len(parts) == 2 {
				return parts[1]
			}
		}
	}
	return "" // Return an empty string if "Severity:" is not found or improperly formatted
}

func ExtractFixValueTrivy(input string) string {
	// Split the input string by newline
	lines := strings.Split(input, "\n")

	// Iterate through each line
	for _, line := range lines {
		if strings.HasPrefix(line, "Fixed Version:") {
			// Split the line by ": " to separate the key and the value
			parts := strings.SplitN(line, ": ", 2)
			if len(parts) == 2 {
				return parts[1]
			}
		}
	}
	return "" // Return an empty string if "Severity:" is not found or improperly formatted
}

func ExtractFixJFrog(inputStr string) string {

	// Define a regular expression to extract the "Fixed Versions" value
	re := regexp.MustCompile(`(?m)\|[^|]*\|[^|]*\|([^|]*)\|`)

	// Find the matches
	matches := re.FindAllStringSubmatch(inputStr, -1)

	// Check if a match is found
	if len(matches) > 0 {
		// Get the last match (the value in the Fixed Versions column)
		lastRow := matches[len(matches)-1]
		if len(lastRow) > 1 {
			fixedVersions := strings.TrimSpace(lastRow[1])
			return fixedVersions
		}
	}
	return ""
}

func ExtractComponentSnyk(input string) string {
	// Find the index of the first occurrence of ')' in the string
	startIndex := strings.Index(input, ")")

	if startIndex == -1 {
		return "" // If ')' is not found, return empty string
	}

	// Extract the substring after ')' (including the space after ')')
	substr := input[startIndex+2:] // startIndex+2 to skip ')' and the space

	return substr
}

func SplitByThirdHyphen(s string) (string, string) {
	count := 0
	index := -1

	// Iterate through the string to find the index of the third occurrence of '-'
	for i, char := range s {
		if char == '-' {
			count++
			if count == 3 {
				index = i
				break
			}
		}
	}

	// If there are fewer than three hyphens, return the original string and an empty string
	if index == -1 {
		return s, ""
	}

	// Split the string at the third hyphen
	before := s[:index]
	after := s[index+1:]

	return before, after
}

func ExtractCVEIDFromStr(inputString string) string {
	// Define the regex pattern to match the CVE ID
	pattern := `CVE-\d{4}-\d+`

	// Compile the regex
	re := regexp.MustCompile(pattern)

	// Find the first match of the pattern in the input string
	match := re.FindString(inputString)

	return match
}

func ExtractCVSSFromStrTRIVY(str string) string {

	// Define the regex pattern to extract the CVSS score
	pattern := `CVSS (\d+\.\d+)`
	re := regexp.MustCompile(pattern)

	// Find the first match
	match := re.FindStringSubmatch(str)
	if match != nil {
		return match[1]
	}
	return ""
}
