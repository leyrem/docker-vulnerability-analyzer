{
  "version": "2.1.0",
  "$schema": "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json",
  "runs": [
    {
      "tool": {
        "driver": {
          "informationUri": "https://docs.jfrog-applications.jfrog.io/jfrog-security-features/sca",
          "name": "JFrog Xray SCA",
          "rules": [
            {
              "id": "CVE-2020-36242_cryptography_3.3.1",
              "shortDescription": {
                "text": "[CVE-2020-36242] cryptography 3.3.1"
              },
              "help": {
                "text": "In the cryptography package before 3.3.2 for Python, certain sequences of update calls to symmetrically encrypt multi-GB values could result in an integer overflow and buffer overflow, as demonstrated by the Fernet class.",
                "markdown": "| Severity Score | Contextual Analysis | Direct Dependencies | Fixed Versions     |\n|  :---:  |  :---:  |  :---:  |  :---:  |\n| 9.1      | Not Covered       | `sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar `       | [3.3.2]   |"
              },
              "properties": {
                "security-severity": "9.1"
              }
            },
            {
              "id": "CVE-2020-22083_jsonpickle_1.4.2",
              "shortDescription": {
                "text": "[CVE-2020-22083] jsonpickle 1.4.2"
              },
              "help": {
                "text": "jsonpickle through 1.4.1 allows remote code execution during deserialization of a malicious payload through the decode() function. Note: It has been argued that this is expected and clearly documented behaviour. pickle is known to be capable of causing arbitrary code execution, and must not be used with un-trusted data",
                "markdown": "| Severity Score | Contextual Analysis | Direct Dependencies | Fixed Versions     |\n|  :---:  |  :---:  |  :---:  |  :---:  |\n| 9.8      | Not Covered       | `sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar `       | No fix available   |"
              },
              "properties": {
                "security-severity": "9.8"
              }
            },
            {
              "id": "CVE-2021-32749_fail2ban_0.11.1",
              "shortDescription": {
                "text": "[CVE-2021-32749] fail2ban 0.11.1"
              },
              "help": {
                "text": "fail2ban is a daemon to ban hosts that cause multiple authentication errors. In versions 0.9.7 and prior, 0.10.0 through 0.10.6, and 0.11.0 through 0.11.2, there is a vulnerability that leads to possible remote code execution in the mailing action mail-whois. Command `mail` from mailutils package used in mail actions like `mail-whois` can execute command if unescaped sequences (`\\n~`) are available in \"foreign\" input (for instance in whois output). To exploit the vulnerability, an attacker would need to insert malicious characters into the response sent by the whois server, either via a MITM attack or by taking over a whois server. The issue is patched in versions 0.10.7 and 0.11.3. As a workaround, one may avoid the usage of action `mail-whois` or patch the vulnerability manually.",
                "markdown": "| Severity Score | Contextual Analysis | Direct Dependencies | Fixed Versions     |\n|  :---:  |  :---:  |  :---:  |  :---:  |\n| 8.1      | Not Covered       | `sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar `       | [0.10.7], [0.11.3]   |"
              },
              "properties": {
                "security-severity": "8.1"
              }
            },
            {
              "id": "CVE-2021-21240_httplib2_0.18.1",
              "shortDescription": {
                "text": "[CVE-2021-21240] httplib2 0.18.1"
              },
              "help": {
                "text": "httplib2 is a comprehensive HTTP client library for Python. In httplib2 before version 0.19.0, a malicious server which responds with long series of \"\\xa0\" characters in the \"www-authenticate\" header may cause Denial of Service (CPU burn while parsing header) of the httplib2 client accessing said server. This is fixed in version 0.19.0 which contains a new implementation of auth headers parsing using the pyparsing library.",
                "markdown": "| Severity Score | Contextual Analysis | Direct Dependencies | Fixed Versions     |\n|  :---:  |  :---:  |  :---:  |  :---:  |\n| 7.5      | Not Covered       | `sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar `       | [0.19.0]   |"
              },
              "properties": {
                "security-severity": "7.5"
              }
            },
            {
              "id": "CVE-2022-40899_future_0.18.2",
              "shortDescription": {
                "text": "[CVE-2022-40899] future 0.18.2"
              },
              "help": {
                "text": "An issue discovered in Python Charmers Future 0.18.2 and earlier allows remote attackers to cause a denial of service via crafted Set-Cookie header from malicious web server.",
                "markdown": "| Severity Score | Contextual Analysis | Direct Dependencies | Fixed Versions     |\n|  :---:  |  :---:  |  :---:  |  :---:  |\n| 7.5      | Not Covered       | `sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar `       | [0.18.3]   |"
              },
              "properties": {
                "security-severity": "7.5"
              }
            },
            {
              "id": "CVE-2018-20225_pip_20.1.1",
              "shortDescription": {
                "text": "[CVE-2018-20225] pip 20.1.1"
              },
              "help": {
                "text": "An issue was discovered in pip (all versions) because it installs the version with the highest version number, even if the user had intended to obtain a private package from a private index. This only affects use of the --extra-index-url option, and exploitation requires that the package does not already exist in the public index (and thus the attacker can put the package there with an arbitrary version number). NOTE: it has been reported that this is intended functionality and the user is responsible for using --extra-index-url securely",
                "markdown": "| Severity Score | Contextual Analysis | Direct Dependencies | Fixed Versions     |\n|  :---:  |  :---:  |  :---:  |  :---:  |\n| 7.8      | Not Covered       | `sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar `       | No fix available   |"
              },
              "properties": {
                "security-severity": "7.8"
              }
            },
            {
              "id": "CVE-2018-20225_pip_20.3.3",
              "shortDescription": {
                "text": "[CVE-2018-20225] pip 20.3.3"
              },
              "help": {
                "text": "An issue was discovered in pip (all versions) because it installs the version with the highest version number, even if the user had intended to obtain a private package from a private index. This only affects use of the --extra-index-url option, and exploitation requires that the package does not already exist in the public index (and thus the attacker can put the package there with an arbitrary version number). NOTE: it has been reported that this is intended functionality and the user is responsible for using --extra-index-url securely",
                "markdown": "| Severity Score | Contextual Analysis | Direct Dependencies | Fixed Versions     |\n|  :---:  |  :---:  |  :---:  |  :---:  |\n| 7.8      | Not Covered       | `sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar `       | No fix available   |"
              },
              "properties": {
                "security-severity": "7.8"
              }
            },
            {
              "id": "CVE-2022-4304_cryptography_3.3.1",
              "shortDescription": {
                "text": "[CVE-2022-4304] cryptography 3.3.1"
              },
              "help": {
                "text": "A timing based side channel exists in the OpenSSL RSA Decryption implementation\nwhich could be sufficient to recover a plaintext across a network in a\nBleichenbacher style attack. To achieve a successful decryption an attacker\nwould have to be able to send a very large number of trial messages for\ndecryption. The vulnerability affects all RSA padding modes: PKCS#1 v1.5,\nRSA-OEAP and RSASVE.\n\nFor example, in a TLS connection, RSA is commonly used by a client to send an\nencrypted pre-master secret to the server. An attacker that had observed a\ngenuine connection between a client and a server could use this flaw to send\ntrial messages to the server and record the time taken to process them. After a\nsufficiently large number of messages the attacker could recover the pre-master\nsecret used for the original connection and thus be able to decrypt the\napplication data sent over that connection.",
                "markdown": "| Severity Score | Contextual Analysis | Direct Dependencies | Fixed Versions     |\n|  :---:  |  :---:  |  :---:  |  :---:  |\n| 5.9      | Not Covered       | `sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar `       | [39.0.1]   |"
              },
              "properties": {
                "security-severity": "5.9"
              }
            },
            {
              "id": "CVE-2020-25658_rsa_4.6",
              "shortDescription": {
                "text": "[CVE-2020-25658] rsa 4.6"
              },
              "help": {
                "text": "It was found that python-rsa is vulnerable to Bleichenbacher timing attacks. An attacker can use this flaw via the RSA decryption API to decrypt parts of the cipher text encrypted with RSA.",
                "markdown": "| Severity Score | Contextual Analysis | Direct Dependencies | Fixed Versions     |\n|  :---:  |  :---:  |  :---:  |  :---:  |\n| 5.9      | Not Covered       | `sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar `       | [4.7]   |"
              },
              "properties": {
                "security-severity": "5.9"
              }
            },
            {
              "id": "CVE-2021-3572_pip_20.3.3",
              "shortDescription": {
                "text": "[CVE-2021-3572] pip 20.3.3"
              },
              "help": {
                "text": "A flaw was found in python-pip in the way it handled Unicode separators in git references. A remote attacker could possibly use this issue to install a different revision on a repository. The highest threat from this vulnerability is to data integrity. This is fixed in python-pip version 21.1.",
                "markdown": "| Severity Score | Contextual Analysis | Direct Dependencies | Fixed Versions     |\n|  :---:  |  :---:  |  :---:  |  :---:  |\n| 5.7      | Not Covered       | `sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar `       | [21.1]   |"
              },
              "properties": {
                "security-severity": "5.7"
              }
            },
            {
              "id": "CVE-2021-3572_pip_20.1.1",
              "shortDescription": {
                "text": "[CVE-2021-3572] pip 20.1.1"
              },
              "help": {
                "text": "A flaw was found in python-pip in the way it handled Unicode separators in git references. A remote attacker could possibly use this issue to install a different revision on a repository. The highest threat from this vulnerability is to data integrity. This is fixed in python-pip version 21.1.",
                "markdown": "| Severity Score | Contextual Analysis | Direct Dependencies | Fixed Versions     |\n|  :---:  |  :---:  |  :---:  |  :---:  |\n| 5.7      | Not Covered       | `sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar `       | [21.1]   |"
              },
              "properties": {
                "security-severity": "5.7"
              }
            },
            {
              "id": "CVE-2023-29483_dnspython_2.0.0",
              "shortDescription": {
                "text": "[CVE-2023-29483] dnspython 2.0.0"
              },
              "help": {
                "text": "eventlet before 0.35.2, as used in dnspython before 2.6.0, allows remote attackers to interfere with DNS name resolution by quickly sending an invalid packet from the expected IP address and source port, aka a \"TuDoor\" attack. In other words, dnspython does not have the preferred behavior in which the DNS name resolution algorithm would proceed, within the full time window, in order to wait for a valid packet. NOTE: dnspython 2.6.0 is unusable for a different reason that was addressed in 2.6.1.",
                "markdown": "| Severity Score | Contextual Analysis | Direct Dependencies | Fixed Versions     |\n|  :---:  |  :---:  |  :---:  |  :---:  |\n| 5.9      | Not Covered       | `sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar `       | [2.6.1]   |"
              },
              "properties": {
                "security-severity": "5.9"
              }
            },
            {
              "id": "CVE-2021-22570_protobuf_3.14.0",
              "shortDescription": {
                "text": "[CVE-2021-22570] protobuf 3.14.0"
              },
              "help": {
                "text": "Nullptr dereference when a null char is present in a proto symbol. The symbol is parsed incorrectly, leading to an unchecked call into the proto file's name during generation of the resulting error message. Since the symbol is incorrectly parsed, the file is nullptr. We recommend upgrading to version 3.15.0 or greater.",
                "markdown": "| Severity Score | Contextual Analysis | Direct Dependencies | Fixed Versions     |\n|  :---:  |  :---:  |  :---:  |  :---:  |\n| 5.5      | Not Covered       | `sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar `       | [3.15.0]   |"
              },
              "properties": {
                "security-severity": "5.5"
              }
            },
            {
              "id": "CVE-2023-3446_cryptography_3.3.1",
              "shortDescription": {
                "text": "[CVE-2023-3446] cryptography 3.3.1"
              },
              "help": {
                "text": "Issue summary: Checking excessively long DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_check(), DH_check_ex()\nor EVP_PKEY_param_check() to check a DH key or DH parameters may experience long\ndelays. Where the key or parameters that are being checked have been obtained\nfrom an untrusted source this may lead to a Denial of Service.\n\nThe function DH_check() performs various checks on DH parameters. One of those\nchecks confirms that the modulus ('p' parameter) is not too large. Trying to use\na very large modulus is slow and OpenSSL will not normally use a modulus which\nis over 10,000 bits in length.\n\nHowever the DH_check() function checks numerous aspects of the key or parameters\nthat have been supplied. Some of those checks use the supplied modulus value\neven if it has already been found to be too large.\n\nAn application that calls DH_check() and supplies a key or parameters obtained\nfrom an untrusted source could be vulernable to a Denial of Service attack.\n\nThe function DH_check() is itself called by a number of other OpenSSL functions.\nAn application calling any of those other functions may similarly be affected.\nThe other functions affected by this are DH_check_ex() and\nEVP_PKEY_param_check().\n\nAlso vulnerable are the OpenSSL dhparam and pkeyparam command line applications\nwhen using the '-check' option.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.",
                "markdown": "| Severity Score | Contextual Analysis | Direct Dependencies | Fixed Versions     |\n|  :---:  |  :---:  |  :---:  |  :---:  |\n| 5.3      | Not Covered       | `sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar `       | [41.0.3]   |"
              },
              "properties": {
                "security-severity": "5.3"
              }
            },
            {
              "id": "CVE-2023-45803_urllib3_1.25.9",
              "shortDescription": {
                "text": "[CVE-2023-45803] urllib3 1.25.9"
              },
              "help": {
                "text": "urllib3 is a user-friendly HTTP client library for Python. urllib3 previously wouldn't remove the HTTP request body when an HTTP redirect response using status 301, 302, or 303 after the request had its method changed from one that could accept a request body (like `POST`) to `GET` as is required by HTTP RFCs. Although this behavior is not specified in the section for redirects, it can be inferred by piecing together information from different sections and we have observed the behavior in other major HTTP client implementations like curl and web browsers. Because the vulnerability requires a previously trusted service to become compromised in order to have an impact on confidentiality we believe the exploitability of this vulnerability is low. Additionally, many users aren't putting sensitive data in HTTP request bodies, if this is the case then this vulnerability isn't exploitable. Both of the following conditions must be true to be affected by this vulnerability: 1. Using urllib3 and submitting sensitive information in the HTTP request body (such as form data or JSON) and 2. The origin service is compromised and starts redirecting using 301, 302, or 303 to a malicious peer or the redirected-to service becomes compromised. This issue has been addressed in versions 1.26.18 and 2.0.7 and users are advised to update to resolve this issue. Users unable to update should disable redirects for services that aren't expecting to respond with redirects with `redirects=False` and disable automatic redirects with `redirects=False` and handle 301, 302, and 303 redirects manually by stripping the HTTP request body.",
                "markdown": "| Severity Score | Contextual Analysis | Direct Dependencies | Fixed Versions     |\n|  :---:  |  :---:  |  :---:  |  :---:  |\n| 4.2      | Not Covered       | `sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar `       | [1.26.18], [2.0.7]   |"
              },
              "properties": {
                "security-severity": "4.2"
              }
            },
            {
              "id": "CVE-2023-23931_cryptography_3.3.1",
              "shortDescription": {
                "text": "[CVE-2023-23931] cryptography 3.3.1"
              },
              "help": {
                "text": "cryptography is a package designed to expose cryptographic primitives and recipes to Python developers. In affected versions `Cipher.update_into` would accept Python objects which implement the buffer protocol, but provide only immutable buffers. This would allow immutable objects (such as `bytes`) to be mutated, thus violating fundamental rules of Python and resulting in corrupted output. This now correctly raises an exception. This issue has been present since `update_into` was originally introduced in cryptography 1.8.",
                "markdown": "| Severity Score | Contextual Analysis | Direct Dependencies | Fixed Versions     |\n|  :---:  |  :---:  |  :---:  |  :---:  |\n| 6.5      | Not Covered       | `sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar `       | [39.0.1]   |"
              },
              "properties": {
                "security-severity": "6.5"
              }
            },
            {
              "id": "CVE-2024-35195_requests_2.25.1",
              "shortDescription": {
                "text": "[CVE-2024-35195] requests 2.25.1"
              },
              "help": {
                "text": "Requests is a HTTP library. Prior to 2.32.0, when making requests through a Requests `Session`, if the first request is made with `verify=False` to disable cert verification, all subsequent requests to the same host will continue to ignore cert verification regardless of changes to the value of `verify`. This behavior will continue for the lifecycle of the connection in the connection pool. This vulnerability is fixed in 2.32.0.",
                "markdown": "| Severity Score | Contextual Analysis | Direct Dependencies | Fixed Versions     |\n|  :---:  |  :---:  |  :---:  |  :---:  |\n| 5.6      | Not Covered       | `sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar `       | [2.32.0]   |"
              },
              "properties": {
                "security-severity": "5.6"
              }
            },
            {
              "id": "CVE-2022-4203_cryptography_3.3.1",
              "shortDescription": {
                "text": "[CVE-2022-4203] cryptography 3.3.1"
              },
              "help": {
                "text": "A read buffer overrun can be triggered in X.509 certificate verification,\nspecifically in name constraint checking. Note that this occurs\nafter certificate chain signature verification and requires either a\nCA to have signed the malicious certificate or for the application to\ncontinue certificate verification despite failure to construct a path\nto a trusted issuer.\n\nThe read buffer overrun might result in a crash which could lead to\na denial of service attack. In theory it could also result in the disclosure\nof private memory contents (such as private keys, or sensitive plaintext)\nalthough we are not aware of any working exploit leading to memory\ncontents disclosure as of the time of release of this advisory.\n\nIn a TLS client, this can be triggered by connecting to a malicious\nserver. In a TLS server, this can be triggered if the server requests\nclient authentication and a malicious client connects.",
                "markdown": "| Severity Score | Contextual Analysis | Direct Dependencies | Fixed Versions     |\n|  :---:  |  :---:  |  :---:  |  :---:  |\n| 4.9      | Not Covered       | `sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar `       | [39.0.1]   |"
              },
              "properties": {
                "security-severity": "4.9"
              }
            },
            {
              "id": "CVE-2024-0727_cryptography_3.3.1",
              "shortDescription": {
                "text": "[CVE-2024-0727] cryptography 3.3.1"
              },
              "help": {
                "text": "Issue summary: Processing a maliciously formatted PKCS12 file may lead OpenSSL\nto crash leading to a potential Denial of Service attack\n\nImpact summary: Applications loading files in the PKCS12 format from untrusted\nsources might terminate abruptly.\n\nA file in PKCS12 format can contain certificates and keys and may come from an\nuntrusted source. The PKCS12 specification allows certain fields to be NULL, but\nOpenSSL does not correctly check for this case. This can lead to a NULL pointer\ndereference that results in OpenSSL crashing. If an application processes PKCS12\nfiles from an untrusted source using the OpenSSL APIs then that application will\nbe vulnerable to this issue.\n\nOpenSSL APIs that are vulnerable to this are: PKCS12_parse(),\nPKCS12_unpack_p7data(), PKCS12_unpack_p7encdata(), PKCS12_unpack_authsafes()\nand PKCS12_newpass().\n\nWe have also fixed a similar issue in SMIME_write_PKCS7(). However since this\nfunction is related to writing data we do not consider it security significant.\n\nThe FIPS modules in 3.2, 3.1 and 3.0 are not affected by this issue.",
                "markdown": "| Severity Score | Contextual Analysis | Direct Dependencies | Fixed Versions     |\n|  :---:  |  :---:  |  :---:  |  :---:  |\n| 5.5      | Not Covered       | `sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar `       | [42.0.2]   |"
              },
              "properties": {
                "security-severity": "5.5"
              }
            },
            {
              "id": "CVE-2023-26112_configobj_5.0.6",
              "shortDescription": {
                "text": "[CVE-2023-26112] configobj 5.0.6"
              },
              "help": {
                "text": "All versions of the package configobj are vulnerable to Regular Expression Denial of Service (ReDoS) via the validate function, using (.+?)\\((.*)\\).\r\r**Note:** This is only exploitable in the case of a developer, putting the offending value in a server side configuration file.",
                "markdown": "| Severity Score | Contextual Analysis | Direct Dependencies | Fixed Versions     |\n|  :---:  |  :---:  |  :---:  |  :---:  |\n| 5.9      | Not Covered       | `sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar `       | No fix available   |"
              },
              "properties": {
                "security-severity": "5.9"
              }
            },
            {
              "id": "CVE-2023-5752_pip_20.3.3",
              "shortDescription": {
                "text": "[CVE-2023-5752] pip 20.3.3"
              },
              "help": {
                "text": "When installing a package from a Mercurial VCS URL  (ie \"pip install \nhg+...\") with pip prior to v23.3, the specified Mercurial revision could\n be used to inject arbitrary configuration options to the \"hg clone\" \ncall (ie \"--config\"). Controlling the Mercurial configuration can modify\n how and which repository is installed. This vulnerability does not \naffect users who aren't installing from Mercurial.",
                "markdown": "| Severity Score | Contextual Analysis | Direct Dependencies | Fixed Versions     |\n|  :---:  |  :---:  |  :---:  |  :---:  |\n| 3.3      | Not Covered       | `sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar `       | [23.3]   |"
              },
              "properties": {
                "security-severity": "3.3"
              }
            },
            {
              "id": "CVE-2023-5752_pip_20.1.1",
              "shortDescription": {
                "text": "[CVE-2023-5752] pip 20.1.1"
              },
              "help": {
                "text": "When installing a package from a Mercurial VCS URL  (ie \"pip install \nhg+...\") with pip prior to v23.3, the specified Mercurial revision could\n be used to inject arbitrary configuration options to the \"hg clone\" \ncall (ie \"--config\"). Controlling the Mercurial configuration can modify\n how and which repository is installed. This vulnerability does not \naffect users who aren't installing from Mercurial.",
                "markdown": "| Severity Score | Contextual Analysis | Direct Dependencies | Fixed Versions     |\n|  :---:  |  :---:  |  :---:  |  :---:  |\n| 3.3      | Not Covered       | `sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar `       | [23.3]   |"
              },
              "properties": {
                "security-severity": "3.3"
              }
            },
            {
              "id": "CVE-2023-37920_certifi_2020.4.5.1",
              "shortDescription": {
                "text": "[CVE-2023-37920] certifi 2020.4.5.1"
              },
              "help": {
                "text": "Certifi is a curated collection of Root Certificates for validating the trustworthiness of SSL certificates while verifying the identity of TLS hosts. Certifi prior to version 2023.07.22 recognizes \"e-Tugra\" root certificates. e-Tugra's root certificates were subject to an investigation prompted by reporting of security issues in their systems. Certifi 2023.07.22 removes root certificates from \"e-Tugra\" from the root store.",
                "markdown": "| Severity Score | Contextual Analysis | Direct Dependencies | Fixed Versions     |\n|  :---:  |  :---:  |  :---:  |  :---:  |\n| 9.8      | Not Applicable       | `sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar `       | [2023.7.22]   |"
              },
              "properties": {
                "security-severity": "9.8"
              }
            },
            {
              "id": "CVE-2020-14343_PyYAML_5.3.1",
              "shortDescription": {
                "text": "[CVE-2020-14343] PyYAML 5.3.1"
              },
              "help": {
                "text": "A vulnerability was discovered in the PyYAML library in versions before 5.4, where it is susceptible to arbitrary code execution when it processes untrusted YAML files through the full_load method or with the FullLoader loader. Applications that use the library to process untrusted input may be vulnerable to this flaw. This flaw allows an attacker to execute arbitrary code on the system by abusing the python/object/new constructor. This flaw is due to an incomplete fix for CVE-2020-1747.",
                "markdown": "| Severity Score | Contextual Analysis | Direct Dependencies | Fixed Versions     |\n|  :---:  |  :---:  |  :---:  |  :---:  |\n| 9.8      | Not Applicable       | `sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar `       | [5.4]   |"
              },
              "properties": {
                "security-severity": "9.8"
              }
            },
            {
              "id": "CVE-2023-0401_cryptography_3.3.1",
              "shortDescription": {
                "text": "[CVE-2023-0401] cryptography 3.3.1"
              },
              "help": {
                "text": "A NULL pointer can be dereferenced when signatures are being\nverified on PKCS7 signed or signedAndEnveloped data. In case the hash\nalgorithm used for the signature is known to the OpenSSL library but\nthe implementation of the hash algorithm is not available the digest\ninitialization will fail. There is a missing check for the return\nvalue from the initialization function which later leads to invalid\nusage of the digest API most likely leading to a crash.\n\nThe unavailability of an algorithm can be caused by using FIPS\nenabled configuration of providers or more commonly by not loading\nthe legacy provider.\n\nPKCS7 data is processed by the SMIME library calls and also by the\ntime stamp (TS) library calls. The TLS implementation in OpenSSL does\nnot call these functions however third party applications would be\naffected if they call these functions to verify signatures on untrusted\ndata.",
                "markdown": "| Severity Score | Contextual Analysis | Direct Dependencies | Fixed Versions     |\n|  :---:  |  :---:  |  :---:  |  :---:  |\n| 7.5      | Not Applicable       | `sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar `       | [39.0.1]   |"
              },
              "properties": {
                "security-severity": "7.5"
              }
            },
            {
              "id": "CVE-2023-43804_urllib3_1.25.9",
              "shortDescription": {
                "text": "[CVE-2023-43804] urllib3 1.25.9"
              },
              "help": {
                "text": "urllib3 is a user-friendly HTTP client library for Python. urllib3 doesn't treat the `Cookie` HTTP header special or provide any helpers for managing cookies over HTTP, that is the responsibility of the user. However, it is possible for a user to specify a `Cookie` header and unknowingly leak information via HTTP redirects to a different origin if that user doesn't disable redirects explicitly. This issue has been patched in urllib3 version 1.26.17 or 2.0.5.",
                "markdown": "| Severity Score | Contextual Analysis | Direct Dependencies | Fixed Versions     |\n|  :---:  |  :---:  |  :---:  |  :---:  |\n| 8.1      | Not Applicable       | `sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar `       | [1.26.17], [2.0.6]   |"
              },
              "properties": {
                "security-severity": "8.1"
              }
            },
            {
              "id": "CVE-2023-0215_cryptography_3.3.1",
              "shortDescription": {
                "text": "[CVE-2023-0215] cryptography 3.3.1"
              },
              "help": {
                "text": "The public API function BIO_new_NDEF is a helper function used for streaming\nASN.1 data via a BIO. It is primarily used internally to OpenSSL to support the\nSMIME, CMS and PKCS7 streaming capabilities, but may also be called directly by\nend user applications.\n\nThe function receives a BIO from the caller, prepends a new BIO_f_asn1 filter\nBIO onto the front of it to form a BIO chain, and then returns the new head of\nthe BIO chain to the caller. Under certain conditions, for example if a CMS\nrecipient public key is invalid, the new filter BIO is freed and the function\nreturns a NULL result indicating a failure. However, in this case, the BIO chain\nis not properly cleaned up and the BIO passed by the caller still retains\ninternal pointers to the previously freed filter BIO. If the caller then goes on\nto call BIO_pop() on the BIO then a use-after-free will occur. This will most\nlikely result in a crash.\n\n\n\nThis scenario occurs directly in the internal function B64_write_ASN1() which\nmay cause BIO_new_NDEF() to be called and will subsequently call BIO_pop() on\nthe BIO. This internal function is in turn called by the public API functions\nPEM_write_bio_ASN1_stream, PEM_write_bio_CMS_stream, PEM_write_bio_PKCS7_stream,\nSMIME_write_ASN1, SMIME_write_CMS and SMIME_write_PKCS7.\n\nOther public API functions that may be impacted by this include\ni2d_ASN1_bio_stream, BIO_new_CMS, BIO_new_PKCS7, i2d_CMS_bio_stream and\ni2d_PKCS7_bio_stream.\n\nThe OpenSSL cms and smime command line applications are similarly affected.",
                "markdown": "| Severity Score | Contextual Analysis | Direct Dependencies | Fixed Versions     |\n|  :---:  |  :---:  |  :---:  |  :---:  |\n| 7.5      | Not Applicable       | `sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar `       | [39.0.1]   |"
              },
              "properties": {
                "security-severity": "7.5"
              }
            },
            {
              "id": "CVE-2022-3996_cryptography_3.3.1",
              "shortDescription": {
                "text": "[CVE-2022-3996] cryptography 3.3.1"
              },
              "help": {
                "text": "If an X.509 certificate contains a malformed policy constraint and\npolicy processing is enabled, then a write lock will be taken twice\nrecursively.  On some operating systems (most widely: Windows) this\nresults in a denial of service when the affected process hangs.  Policy\nprocessing being enabled on a publicly facing server is not considered\nto be a common setup.\n\nPolicy processing is enabled by passing the `-policy'\nargument to the command line utilities or by calling the\n`X509_VERIFY_PARAM_set1_policies()' function.\n\nUpdate (31 March 2023): The description of the policy processing enablement\nwas corrected based on CVE-2023-0466.",
                "markdown": "| Severity Score | Contextual Analysis | Direct Dependencies | Fixed Versions     |\n|  :---:  |  :---:  |  :---:  |  :---:  |\n| 7.5      | Not Applicable       | `sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar `       | [39.0.1]   |"
              },
              "properties": {
                "security-severity": "7.5"
              }
            },
            {
              "id": "CVE-2022-1941_protobuf_3.14.0",
              "shortDescription": {
                "text": "[CVE-2022-1941] protobuf 3.14.0"
              },
              "help": {
                "text": "A parsing vulnerability for the MessageSet type in the ProtocolBuffers versions prior to and including 3.16.1, 3.17.3, 3.18.2, 3.19.4, 3.20.1 and 3.21.5 for protobuf-cpp, and versions prior to and including 3.16.1, 3.17.3, 3.18.2, 3.19.4, 3.20.1 and 4.21.5 for protobuf-python can lead to out of memory failures. A specially crafted message with multiple key-value per elements creates parsing issues, and can lead to a Denial of Service against services receiving unsanitized input. We recommend upgrading to versions 3.18.3, 3.19.5, 3.20.2, 3.21.6 for protobuf-cpp and 3.18.3, 3.19.5, 3.20.2, 4.21.6 for protobuf-python. Versions for 3.16 and 3.17 are no longer updated.",
                "markdown": "| Severity Score | Contextual Analysis | Direct Dependencies | Fixed Versions     |\n|  :---:  |  :---:  |  :---:  |  :---:  |\n| 7.5      | Not Applicable       | `sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar `       | [3.18.3], [3.19.5], [3.20.2], [4.21.6]   |"
              },
              "properties": {
                "security-severity": "7.5"
              }
            },
            {
              "id": "CVE-2021-33503_urllib3_1.25.9",
              "shortDescription": {
                "text": "[CVE-2021-33503] urllib3 1.25.9"
              },
              "help": {
                "text": "An issue was discovered in urllib3 before 1.26.5. When provided with a URL containing many @ characters in the authority component, the authority regular expression exhibits catastrophic backtracking, causing a denial of service if a URL were passed as a parameter or redirected to via an HTTP redirect.",
                "markdown": "| Severity Score | Contextual Analysis | Direct Dependencies | Fixed Versions     |\n|  :---:  |  :---:  |  :---:  |  :---:  |\n| 7.5      | Not Applicable       | `sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar `       | [1.26.5]   |"
              },
              "properties": {
                "security-severity": "7.5"
              }
            },
            {
              "id": "CVE-2023-49083_cryptography_3.3.1",
              "shortDescription": {
                "text": "[CVE-2023-49083] cryptography 3.3.1"
              },
              "help": {
                "text": "cryptography is a package designed to expose cryptographic primitives and recipes to Python developers. Calling `load_pem_pkcs7_certificates` or `load_der_pkcs7_certificates` could lead to a NULL-pointer dereference and segfault. Exploitation of this vulnerability poses a serious risk of Denial of Service (DoS) for any application attempting to deserialize a PKCS7 blob/certificate. The consequences extend to potential disruptions in system availability and stability. This vulnerability has been patched in version 41.0.6.",
                "markdown": "| Severity Score | Contextual Analysis | Direct Dependencies | Fixed Versions     |\n|  :---:  |  :---:  |  :---:  |  :---:  |\n| 7.5      | Not Applicable       | `sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar `       | [41.0.6]   |"
              },
              "properties": {
                "security-severity": "7.5"
              }
            },
            {
              "id": "CVE-2023-0216_cryptography_3.3.1",
              "shortDescription": {
                "text": "[CVE-2023-0216] cryptography 3.3.1"
              },
              "help": {
                "text": "An invalid pointer dereference on read can be triggered when an\napplication tries to load malformed PKCS7 data with the\nd2i_PKCS7(), d2i_PKCS7_bio() or d2i_PKCS7_fp() functions.\n\nThe result of the dereference is an application crash which could\nlead to a denial of service attack. The TLS implementation in OpenSSL\ndoes not call this function however third party applications might\ncall these functions on untrusted data.",
                "markdown": "| Severity Score | Contextual Analysis | Direct Dependencies | Fixed Versions     |\n|  :---:  |  :---:  |  :---:  |  :---:  |\n| 7.5      | Not Applicable       | `sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar `       | [39.0.1]   |"
              },
              "properties": {
                "security-severity": "7.5"
              }
            },
            {
              "id": "CVE-2022-23491_certifi_2020.4.5.1",
              "shortDescription": {
                "text": "[CVE-2022-23491] certifi 2020.4.5.1"
              },
              "help": {
                "text": "Certifi is a curated collection of Root Certificates for validating the trustworthiness of SSL certificates while verifying the identity of TLS hosts. Certifi 2022.12.07 removes root certificates from \"TrustCor\" from the root store. These are in the process of being removed from Mozilla's trust store. TrustCor's root certificates are being removed pursuant to an investigation prompted by media reporting that TrustCor's ownership also operated a business that produced spyware. Conclusions of Mozilla's investigation can be found in the linked google group discussion.",
                "markdown": "| Severity Score | Contextual Analysis | Direct Dependencies | Fixed Versions     |\n|  :---:  |  :---:  |  :---:  |  :---:  |\n| 7.5      | Not Applicable       | `sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar `       | [2022.12.07]   |"
              },
              "properties": {
                "security-severity": "7.5"
              }
            },
            {
              "id": "CVE-2023-50782_cryptography_3.3.1",
              "shortDescription": {
                "text": "[CVE-2023-50782] cryptography 3.3.1"
              },
              "help": {
                "text": "A flaw was found in the python-cryptography package. This issue may allow a remote attacker to decrypt captured messages in TLS servers that use RSA key exchanges, which may lead to exposure of confidential or sensitive data.",
                "markdown": "| Severity Score | Contextual Analysis | Direct Dependencies | Fixed Versions     |\n|  :---:  |  :---:  |  :---:  |  :---:  |\n| 7.5      | Not Applicable       | `sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar `       | [42.0.0]   |"
              },
              "properties": {
                "security-severity": "7.5"
              }
            },
            {
              "id": "CVE-2023-0286_cryptography_3.3.1",
              "shortDescription": {
                "text": "[CVE-2023-0286] cryptography 3.3.1"
              },
              "help": {
                "text": "There is a type confusion vulnerability relating to X.400 address processing\ninside an X.509 GeneralName. X.400 addresses were parsed as an ASN1_STRING but\nthe public structure definition for GENERAL_NAME incorrectly specified the type\nof the x400Address field as ASN1_TYPE. This field is subsequently interpreted by\nthe OpenSSL function GENERAL_NAME_cmp as an ASN1_TYPE rather than an\nASN1_STRING.\n\nWhen CRL checking is enabled (i.e. the application sets the\nX509_V_FLAG_CRL_CHECK flag), this vulnerability may allow an attacker to pass\narbitrary pointers to a memcmp call, enabling them to read memory contents or\nenact a denial of service. In most cases, the attack requires the attacker to\nprovide both the certificate chain and CRL, neither of which need to have a\nvalid signature. If the attacker only controls one of these inputs, the other\ninput must already contain an X.400 address as a CRL distribution point, which\nis uncommon. As such, this vulnerability is most likely to only affect\napplications which have implemented their own functionality for retrieving CRLs\nover a network.",
                "markdown": "| Severity Score | Contextual Analysis | Direct Dependencies | Fixed Versions     |\n|  :---:  |  :---:  |  :---:  |  :---:  |\n| 7.4      | Not Applicable       | `sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar `       | [39.0.1]   |"
              },
              "properties": {
                "security-severity": "7.4"
              }
            },
            {
              "id": "CVE-2023-0217_cryptography_3.3.1",
              "shortDescription": {
                "text": "[CVE-2023-0217] cryptography 3.3.1"
              },
              "help": {
                "text": "An invalid pointer dereference on read can be triggered when an\napplication tries to check a malformed DSA public key by the\nEVP_PKEY_public_check() function. This will most likely lead\nto an application crash. This function can be called on public\nkeys supplied from untrusted sources which could allow an attacker\nto cause a denial of service attack.\n\nThe TLS implementation in OpenSSL does not call this function\nbut applications might call the function if there are additional\nsecurity requirements imposed by standards such as FIPS 140-3.",
                "markdown": "| Severity Score | Contextual Analysis | Direct Dependencies | Fixed Versions     |\n|  :---:  |  :---:  |  :---:  |  :---:  |\n| 7.5      | Not Applicable       | `sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar `       | [39.0.1]   |"
              },
              "properties": {
                "security-severity": "7.5"
              }
            },
            {
              "id": "CVE-2023-4807_cryptography_3.3.1",
              "shortDescription": {
                "text": "[CVE-2023-4807] cryptography 3.3.1"
              },
              "help": {
                "text": "Issue summary: The POLY1305 MAC (message authentication code) implementation\ncontains a bug that might corrupt the internal state of applications on the\nWindows 64 platform when running on newer X86_64 processors supporting the\nAVX512-IFMA instructions.\n\nImpact summary: If in an application that uses the OpenSSL library an attacker\ncan influence whether the POLY1305 MAC algorithm is used, the application\nstate might be corrupted with various application dependent consequences.\n\nThe POLY1305 MAC (message authentication code) implementation in OpenSSL does\nnot save the contents of non-volatile XMM registers on Windows 64 platform\nwhen calculating the MAC of data larger than 64 bytes. Before returning to\nthe caller all the XMM registers are set to zero rather than restoring their\nprevious content. The vulnerable code is used only on newer x86_64 processors\nsupporting the AVX512-IFMA instructions.\n\nThe consequences of this kind of internal application state corruption can\nbe various - from no consequences, if the calling application does not\ndepend on the contents of non-volatile XMM registers at all, to the worst\nconsequences, where the attacker could get complete control of the application\nprocess. However given the contents of the registers are just zeroized so\nthe attacker cannot put arbitrary values inside, the most likely consequence,\nif any, would be an incorrect result of some application dependent\ncalculations or a crash leading to a denial of service.\n\nThe POLY1305 MAC algorithm is most frequently used as part of the\nCHACHA20-POLY1305 AEAD (authenticated encryption with associated data)\nalgorithm. The most common usage of this AEAD cipher is with TLS protocol\nversions 1.2 and 1.3 and a malicious client can influence whether this AEAD\ncipher is used by the server. This implies that server applications using\nOpenSSL can be potentially impacted. However we are currently not aware of\nany concrete application that would be affected by this issue therefore we\nconsider this a Low severity security issue.\n\n...",
                "markdown": "| Severity Score | Contextual Analysis | Direct Dependencies | Fixed Versions     |\n|  :---:  |  :---:  |  :---:  |  :---:  |\n| 7.8      | Not Applicable       | `sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar `       | [41.0.4]   |"
              },
              "properties": {
                "security-severity": "7.8"
              }
            },
            {
              "id": "CVE-2022-4450_cryptography_3.3.1",
              "shortDescription": {
                "text": "[CVE-2022-4450] cryptography 3.3.1"
              },
              "help": {
                "text": "The function PEM_read_bio_ex() reads a PEM file from a BIO and parses and\ndecodes the \"name\" (e.g. \"CERTIFICATE\"), any header data and the payload data.\nIf the function succeeds then the \"name_out\", \"header\" and \"data\" arguments are\npopulated with pointers to buffers containing the relevant decoded data. The\ncaller is responsible for freeing those buffers. It is possible to construct a\nPEM file that results in 0 bytes of payload data. In this case PEM_read_bio_ex()\nwill return a failure code but will populate the header argument with a pointer\nto a buffer that has already been freed. If the caller also frees this buffer\nthen a double free will occur. This will most likely lead to a crash. This\ncould be exploited by an attacker who has the ability to supply malicious PEM\nfiles for parsing to achieve a denial of service attack.\n\nThe functions PEM_read_bio() and PEM_read() are simple wrappers around\nPEM_read_bio_ex() and therefore these functions are also directly affected.\n\nThese functions are also called indirectly by a number of other OpenSSL\nfunctions including PEM_X509_INFO_read_bio_ex() and\nSSL_CTX_use_serverinfo_file() which are also vulnerable. Some OpenSSL internal\nuses of these functions are not vulnerable because the caller does not free the\nheader argument if PEM_read_bio_ex() returns a failure code. These locations\ninclude the PEM_read_bio_TYPE() functions as well as the decoders introduced in\nOpenSSL 3.0.\n\nThe OpenSSL asn1parse command line application is also impacted by this issue.",
                "markdown": "| Severity Score | Contextual Analysis | Direct Dependencies | Fixed Versions     |\n|  :---:  |  :---:  |  :---:  |  :---:  |\n| 7.5      | Not Applicable       | `sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar `       | [39.0.1]   |"
              },
              "properties": {
                "security-severity": "7.5"
              }
            },
            {
              "id": "CVE-2022-40897_setuptools_47.1.0",
              "shortDescription": {
                "text": "[CVE-2022-40897] setuptools 47.1.0"
              },
              "help": {
                "text": "Python Packaging Authority (PyPA) setuptools before 65.5.1 allows remote attackers to cause a denial of service via HTML in a crafted package or custom PackageIndex page. There is a Regular Expression Denial of Service (ReDoS) in package_index.py.",
                "markdown": "| Severity Score | Contextual Analysis | Direct Dependencies | Fixed Versions     |\n|  :---:  |  :---:  |  :---:  |  :---:  |\n| 5.9      | Not Applicable       | `sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar `       | [65.5.1]   |"
              },
              "properties": {
                "security-severity": "5.9"
              }
            },
            {
              "id": "CVE-2022-40897_setuptools_47.0.0",
              "shortDescription": {
                "text": "[CVE-2022-40897] setuptools 47.0.0"
              },
              "help": {
                "text": "Python Packaging Authority (PyPA) setuptools before 65.5.1 allows remote attackers to cause a denial of service via HTML in a crafted package or custom PackageIndex page. There is a Regular Expression Denial of Service (ReDoS) in package_index.py.",
                "markdown": "| Severity Score | Contextual Analysis | Direct Dependencies | Fixed Versions     |\n|  :---:  |  :---:  |  :---:  |  :---:  |\n| 5.9      | Not Applicable       | `sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar `       | [65.5.1]   |"
              },
              "properties": {
                "security-severity": "5.9"
              }
            },
            {
              "id": "CVE-2023-2650_cryptography_3.3.1",
              "shortDescription": {
                "text": "[CVE-2023-2650] cryptography 3.3.1"
              },
              "help": {
                "text": "Issue summary: Processing some specially crafted ASN.1 object identifiers or\ndata containing them may be very slow.\n\nImpact summary: Applications that use OBJ_obj2txt() directly, or use any of\nthe OpenSSL subsystems OCSP, PKCS7/SMIME, CMS, CMP/CRMF or TS with no message\nsize limit may experience notable to very long delays when processing those\nmessages, which may lead to a Denial of Service.\n\nAn OBJECT IDENTIFIER is composed of a series of numbers - sub-identifiers -\nmost of which have no size limit.  OBJ_obj2txt() may be used to translate\nan ASN.1 OBJECT IDENTIFIER given in DER encoding form (using the OpenSSL\ntype ASN1_OBJECT) to its canonical numeric text form, which are the\nsub-identifiers of the OBJECT IDENTIFIER in decimal form, separated by\nperiods.\n\nWhen one of the sub-identifiers in the OBJECT IDENTIFIER is very large\n(these are sizes that are seen as absurdly large, taking up tens or hundreds\nof KiBs), the translation to a decimal number in text may take a very long\ntime.  The time complexity is O(n^2) with 'n' being the size of the\nsub-identifiers in bytes (*).\n\nWith OpenSSL 3.0, support to fetch cryptographic algorithms using names /\nidentifiers in string form was introduced.  This includes using OBJECT\nIDENTIFIERs in canonical numeric text form as identifiers for fetching\nalgorithms.\n\nSuch OBJECT IDENTIFIERs may be received through the ASN.1 structure\nAlgorithmIdentifier, which is commonly used in multiple protocols to specify\nwhat cryptographic algorithm should be used to sign or verify, encrypt or\ndecrypt, or digest passed data.\n\nApplications that call OBJ_obj2txt() directly with untrusted data are\naffected, with any version of OpenSSL.  If the use is for the mere purpose\nof display, the severity is considered low.\n\nIn OpenSSL 3.0 and newer, this affects the subsystems OCSP, PKCS7/SMIME,\nCMS, CMP/CRMF or TS.  It also impacts anything that processes X.509\ncertificates, including simple things like verifying its signature.\n\nThe impact on TLS is relatively low, because all versions of OpenSSL...",
                "markdown": "| Severity Score | Contextual Analysis | Direct Dependencies | Fixed Versions     |\n|  :---:  |  :---:  |  :---:  |  :---:  |\n| 6.5      | Not Applicable       | `sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar `       | [41.0.0]   |"
              },
              "properties": {
                "security-severity": "6.5"
              }
            },
            {
              "id": "CVE-2023-32681_requests_2.25.1",
              "shortDescription": {
                "text": "[CVE-2023-32681] requests 2.25.1"
              },
              "help": {
                "text": "Requests is a HTTP library. Since Requests 2.3.0, Requests has been leaking Proxy-Authorization headers to destination servers when redirected to an HTTPS endpoint. This is a product of how we use `rebuild_proxies` to reattach the `Proxy-Authorization` header to requests. For HTTP connections sent through the tunnel, the proxy will identify the header in the request itself and remove it prior to forwarding to the destination server. However when sent over HTTPS, the `Proxy-Authorization` header must be sent in the CONNECT request as the proxy has no visibility into the tunneled request. This results in Requests forwarding proxy credentials to the destination server unintentionally, allowing a malicious actor to potentially exfiltrate sensitive information. This issue has been patched in version 2.31.0.",
                "markdown": "| Severity Score | Contextual Analysis | Direct Dependencies | Fixed Versions     |\n|  :---:  |  :---:  |  :---:  |  :---:  |\n| 6.1      | Not Applicable       | `sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar `       | [2.31.0]   |"
              },
              "properties": {
                "security-severity": "6.1"
              }
            }
          ],
          "version": "3.96.1"
        }
      },
      "results": [
        {
          "ruleId": "CVE-2020-36242_cryptography_3.3.1",
          "ruleIndex": 0,
          "level": "error",
          "message": {
            "text": "[CVE-2020-36242] sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar "
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file://Package-Descriptor"
                }
              }
            }
          ]
        },
        {
          "ruleId": "CVE-2020-22083_jsonpickle_1.4.2",
          "ruleIndex": 1,
          "level": "error",
          "message": {
            "text": "[CVE-2020-22083] sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar "
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file://Package-Descriptor"
                }
              }
            }
          ]
        },
        {
          "ruleId": "CVE-2021-32749_fail2ban_0.11.1",
          "ruleIndex": 2,
          "level": "error",
          "message": {
            "text": "[CVE-2021-32749] sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar "
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file://Package-Descriptor"
                }
              }
            }
          ]
        },
        {
          "ruleId": "CVE-2021-21240_httplib2_0.18.1",
          "ruleIndex": 3,
          "level": "error",
          "message": {
            "text": "[CVE-2021-21240] sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar "
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file://Package-Descriptor"
                }
              }
            }
          ]
        },
        {
          "ruleId": "CVE-2022-40899_future_0.18.2",
          "ruleIndex": 4,
          "level": "error",
          "message": {
            "text": "[CVE-2022-40899] sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar "
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file://Package-Descriptor"
                }
              }
            }
          ]
        },
        {
          "ruleId": "CVE-2018-20225_pip_20.1.1",
          "ruleIndex": 5,
          "level": "error",
          "message": {
            "text": "[CVE-2018-20225] sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar "
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file://Package-Descriptor"
                }
              }
            }
          ]
        },
        {
          "ruleId": "CVE-2018-20225_pip_20.3.3",
          "ruleIndex": 6,
          "level": "error",
          "message": {
            "text": "[CVE-2018-20225] sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar "
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file://Package-Descriptor"
                }
              }
            }
          ]
        },
        {
          "ruleId": "CVE-2022-4304_cryptography_3.3.1",
          "ruleIndex": 7,
          "level": "warning",
          "message": {
            "text": "[CVE-2022-4304] sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar "
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file://Package-Descriptor"
                }
              }
            }
          ]
        },
        {
          "ruleId": "CVE-2020-25658_rsa_4.6",
          "ruleIndex": 8,
          "level": "warning",
          "message": {
            "text": "[CVE-2020-25658] sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar "
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file://Package-Descriptor"
                }
              }
            }
          ]
        },
        {
          "ruleId": "CVE-2021-3572_pip_20.3.3",
          "ruleIndex": 9,
          "level": "warning",
          "message": {
            "text": "[CVE-2021-3572] sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar "
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file://Package-Descriptor"
                }
              }
            }
          ]
        },
        {
          "ruleId": "CVE-2021-3572_pip_20.1.1",
          "ruleIndex": 10,
          "level": "warning",
          "message": {
            "text": "[CVE-2021-3572] sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar "
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file://Package-Descriptor"
                }
              }
            }
          ]
        },
        {
          "ruleId": "CVE-2023-29483_dnspython_2.0.0",
          "ruleIndex": 11,
          "level": "warning",
          "message": {
            "text": "[CVE-2023-29483] sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar "
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file://Package-Descriptor"
                }
              }
            }
          ]
        },
        {
          "ruleId": "CVE-2021-22570_protobuf_3.14.0",
          "ruleIndex": 12,
          "level": "warning",
          "message": {
            "text": "[CVE-2021-22570] sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar "
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file://Package-Descriptor"
                }
              }
            }
          ]
        },
        {
          "ruleId": "CVE-2023-3446_cryptography_3.3.1",
          "ruleIndex": 13,
          "level": "warning",
          "message": {
            "text": "[CVE-2023-3446] sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar "
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file://Package-Descriptor"
                }
              }
            }
          ]
        },
        {
          "ruleId": "CVE-2023-45803_urllib3_1.25.9",
          "ruleIndex": 14,
          "level": "warning",
          "message": {
            "text": "[CVE-2023-45803] sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar "
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file://Package-Descriptor"
                }
              }
            }
          ]
        },
        {
          "ruleId": "CVE-2023-23931_cryptography_3.3.1",
          "ruleIndex": 15,
          "level": "warning",
          "message": {
            "text": "[CVE-2023-23931] sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar "
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file://Package-Descriptor"
                }
              }
            }
          ]
        },
        {
          "ruleId": "CVE-2024-35195_requests_2.25.1",
          "ruleIndex": 16,
          "level": "warning",
          "message": {
            "text": "[CVE-2024-35195] sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar "
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file://Package-Descriptor"
                }
              }
            }
          ]
        },
        {
          "ruleId": "CVE-2022-4203_cryptography_3.3.1",
          "ruleIndex": 17,
          "level": "warning",
          "message": {
            "text": "[CVE-2022-4203] sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar "
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file://Package-Descriptor"
                }
              }
            }
          ]
        },
        {
          "ruleId": "CVE-2024-0727_cryptography_3.3.1",
          "ruleIndex": 18,
          "level": "warning",
          "message": {
            "text": "[CVE-2024-0727] sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar "
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file://Package-Descriptor"
                }
              }
            }
          ]
        },
        {
          "ruleId": "CVE-2023-26112_configobj_5.0.6",
          "ruleIndex": 19,
          "level": "warning",
          "message": {
            "text": "[CVE-2023-26112] sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar "
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file://Package-Descriptor"
                }
              }
            }
          ]
        },
        {
          "ruleId": "CVE-2023-5752_pip_20.3.3",
          "ruleIndex": 20,
          "level": "note",
          "message": {
            "text": "[CVE-2023-5752] sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar "
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file://Package-Descriptor"
                }
              }
            }
          ]
        },
        {
          "ruleId": "CVE-2023-5752_pip_20.1.1",
          "ruleIndex": 21,
          "level": "note",
          "message": {
            "text": "[CVE-2023-5752] sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar "
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file://Package-Descriptor"
                }
              }
            }
          ]
        },
        {
          "ruleId": "CVE-2023-37920_certifi_2020.4.5.1",
          "ruleIndex": 22,
          "level": "error",
          "message": {
            "text": "[CVE-2023-37920] sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar "
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file://Package-Descriptor"
                }
              }
            }
          ]
        },
        {
          "ruleId": "CVE-2020-14343_PyYAML_5.3.1",
          "ruleIndex": 23,
          "level": "error",
          "message": {
            "text": "[CVE-2020-14343] sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar "
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file://Package-Descriptor"
                }
              }
            }
          ]
        },
        {
          "ruleId": "CVE-2023-0401_cryptography_3.3.1",
          "ruleIndex": 24,
          "level": "error",
          "message": {
            "text": "[CVE-2023-0401] sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar "
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file://Package-Descriptor"
                }
              }
            }
          ]
        },
        {
          "ruleId": "CVE-2023-43804_urllib3_1.25.9",
          "ruleIndex": 25,
          "level": "error",
          "message": {
            "text": "[CVE-2023-43804] sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar "
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file://Package-Descriptor"
                }
              }
            }
          ]
        },
        {
          "ruleId": "CVE-2023-0215_cryptography_3.3.1",
          "ruleIndex": 26,
          "level": "error",
          "message": {
            "text": "[CVE-2023-0215] sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar "
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file://Package-Descriptor"
                }
              }
            }
          ]
        },
        {
          "ruleId": "CVE-2022-3996_cryptography_3.3.1",
          "ruleIndex": 27,
          "level": "error",
          "message": {
            "text": "[CVE-2022-3996] sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar "
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file://Package-Descriptor"
                }
              }
            }
          ]
        },
        {
          "ruleId": "CVE-2022-1941_protobuf_3.14.0",
          "ruleIndex": 28,
          "level": "error",
          "message": {
            "text": "[CVE-2022-1941] sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar "
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file://Package-Descriptor"
                }
              }
            }
          ]
        },
        {
          "ruleId": "CVE-2021-33503_urllib3_1.25.9",
          "ruleIndex": 29,
          "level": "error",
          "message": {
            "text": "[CVE-2021-33503] sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar "
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file://Package-Descriptor"
                }
              }
            }
          ]
        },
        {
          "ruleId": "CVE-2023-49083_cryptography_3.3.1",
          "ruleIndex": 30,
          "level": "error",
          "message": {
            "text": "[CVE-2023-49083] sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar "
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file://Package-Descriptor"
                }
              }
            }
          ]
        },
        {
          "ruleId": "CVE-2023-0216_cryptography_3.3.1",
          "ruleIndex": 31,
          "level": "error",
          "message": {
            "text": "[CVE-2023-0216] sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar "
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file://Package-Descriptor"
                }
              }
            }
          ]
        },
        {
          "ruleId": "CVE-2022-23491_certifi_2020.4.5.1",
          "ruleIndex": 32,
          "level": "error",
          "message": {
            "text": "[CVE-2022-23491] sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar "
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file://Package-Descriptor"
                }
              }
            }
          ]
        },
        {
          "ruleId": "CVE-2023-50782_cryptography_3.3.1",
          "ruleIndex": 33,
          "level": "error",
          "message": {
            "text": "[CVE-2023-50782] sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar "
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file://Package-Descriptor"
                }
              }
            }
          ]
        },
        {
          "ruleId": "CVE-2023-0286_cryptography_3.3.1",
          "ruleIndex": 34,
          "level": "error",
          "message": {
            "text": "[CVE-2023-0286] sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar "
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file://Package-Descriptor"
                }
              }
            }
          ]
        },
        {
          "ruleId": "CVE-2023-0217_cryptography_3.3.1",
          "ruleIndex": 35,
          "level": "error",
          "message": {
            "text": "[CVE-2023-0217] sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar "
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file://Package-Descriptor"
                }
              }
            }
          ]
        },
        {
          "ruleId": "CVE-2023-4807_cryptography_3.3.1",
          "ruleIndex": 36,
          "level": "error",
          "message": {
            "text": "[CVE-2023-4807] sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar "
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file://Package-Descriptor"
                }
              }
            }
          ]
        },
        {
          "ruleId": "CVE-2022-4450_cryptography_3.3.1",
          "ruleIndex": 37,
          "level": "error",
          "message": {
            "text": "[CVE-2022-4450] sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar "
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file://Package-Descriptor"
                }
              }
            }
          ]
        },
        {
          "ruleId": "CVE-2022-40897_setuptools_47.1.0",
          "ruleIndex": 38,
          "level": "warning",
          "message": {
            "text": "[CVE-2022-40897] sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar "
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file://Package-Descriptor"
                }
              }
            }
          ]
        },
        {
          "ruleId": "CVE-2022-40897_setuptools_47.0.0",
          "ruleIndex": 39,
          "level": "warning",
          "message": {
            "text": "[CVE-2022-40897] sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar "
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file://Package-Descriptor"
                }
              }
            }
          ]
        },
        {
          "ruleId": "CVE-2023-2650_cryptography_3.3.1",
          "ruleIndex": 40,
          "level": "warning",
          "message": {
            "text": "[CVE-2023-2650] sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar "
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file://Package-Descriptor"
                }
              }
            }
          ]
        },
        {
          "ruleId": "CVE-2023-32681_requests_2.25.1",
          "ruleIndex": 41,
          "level": "warning",
          "message": {
            "text": "[CVE-2023-32681] sha256__6f5424f524bf5402719fdd063e978ef227e98ad0ec97b6bd78019c931b238290.tar "
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file://Package-Descriptor"
                }
              }
            }
          ]
        }
      ]
    },
    {
      "tool": {
        "driver": {
          "informationUri": "https://jfrog.com/help/r/jfrog-security-documentation/jfrog-advanced-security",
          "name": "JFrog Applicability Scanner",
          "rules": [
            {
              "id": "applic_CVE-2020-14343",
              "name": "CVE-2020-14343",
              "shortDescription": {
                "text": "Scanner for CVE-2020-14343"
              },
              "fullDescription": {
                "text": "The scanner checks whether any of the following vulnerable functions are called:\n\n-  `yaml.full_load()`\n-  `yaml.load()` only unsafe calls (without specifying `SafeLoader` as the `Loader`class).",
                "markdown": "The scanner checks whether any of the following vulnerable functions are called:\n\n-  `yaml.full_load()`\n-  `yaml.load()` only unsafe calls (without specifying `SafeLoader` as the `Loader`class)."
              },
              "properties": {
                "applicability": "not_applicable",
                "conclusion": "positive",
                "security-severity": "6.9"
              }
            },
            {
              "id": "applic_CVE-2022-3996",
              "name": "CVE-2022-3996",
              "shortDescription": {
                "text": "Scanner for CVE-2022-3996"
              },
              "fullDescription": {
                "text": "The vulnerability is only exploitable when running under the Windows OS.\nSince currently only Linux containers are supported, the scanner will always conclude that this vulnerability is not applicable.",
                "markdown": "The vulnerability is only exploitable when running under the Windows OS.\nSince currently only Linux containers are supported, the scanner will always conclude that this vulnerability is not applicable."
              },
              "properties": {
                "applicability": "not_applicable",
                "conclusion": "positive",
                "security-severity": "6.9"
              }
            },
            {
              "id": "applic_CVE-2023-4807",
              "name": "CVE-2023-4807",
              "shortDescription": {
                "text": "Scanner for CVE-2023-4807"
              },
              "fullDescription": {
                "text": "The vulnerability is only exploitable when running under the Windows OS.\nSince currently only Linux containers are supported, the scanner will always conclude that this vulnerability is not applicable.",
                "markdown": "The vulnerability is only exploitable when running under the Windows OS.\nSince currently only Linux containers are supported, the scanner will always conclude that this vulnerability is not applicable."
              },
              "properties": {
                "applicability": "not_applicable",
                "conclusion": "positive",
                "security-severity": "6.9"
              }
            },
            {
              "id": "applic_CVE-2022-40897",
              "name": "CVE-2022-40897",
              "shortDescription": {
                "text": "Scanner for CVE-2022-40897"
              },
              "fullDescription": {
                "text": "The scanner checks whether the vulnerable function `find_external_links` is called.\n\nNote that the scanner does not check for an additional vulnerable case in which the `pip` CLI tool is executed with the  `--editable` flag. In this case, the vulnerability will lead to a DoS of a forked command-line utility, which has a minimal security impact.",
                "markdown": "The scanner checks whether the vulnerable function `find_external_links` is called.\n\nNote that the scanner does not check for an additional vulnerable case in which the `pip` CLI tool is executed with the  `--editable` flag. In this case, the vulnerability will lead to a DoS of a forked command-line utility, which has a minimal security impact."
              },
              "properties": {
                "applicability": "not_applicable",
                "conclusion": "positive",
                "security-severity": "6.9"
              }
            },
            {
              "id": "applic_CVE-2022-4450",
              "name": "CVE-2022-4450",
              "shortDescription": {
                "text": "Scanner for CVE-2022-4450"
              },
              "fullDescription": {
                "text": "The scanner checks if at least one of the vulnerable functions is called:\n```\nPEM_read_bio_ex()\nPEM_read_bio()\nPEM_read()\nPEM_read_DHparams()\nPEM_read_PrivateKey()\nPEM_read_bio_PrivateKey()\nPEM_read_RSA_PUBKEY()\nPEM_read_bio_RSA_PUBKEY()\nPEM_read_RSAPrivateKey()\nPEM_read_bio_RSAPrivateKey()\nPEM_read_PKCS7()\nPEM_read_bio_PKCS7()\nPEM_read_X509()\nPEM_read_bio_X509()\nPEM_read_X509_AUX()\nPEM_read_bio_X509_AUX()\nPEM_read_X509_CRL()\nPEM_read_bio_X509_CRL()\nPEM_read_bio_X509_REQ()\nPEM_read_bio_ECPrivateKey()\nPEM_read_bio_PKCS8()\n\nPEM_X509_INFO_read_bio_ex()\nSSL_CTX_use_serverinfo_file()\nSSL_use_cert_and_key() \nSSL_CTX_use_certificate_chain_file()\nSSL_CTX_load_verify_locations()\nSSL_CTX_set1_verify_file()\nSSL_CTX_set1_verify_path()\nX509_LOOKUP_load_file()\n\nSSL_load_client_CA_file_ex()\nSSL_load_client_CA_file()\nSSL_add_file_cert_subjects_to_stack()\nSSL_add_dir_cert_subjects_to_stack()\nSSL_add_store_cert_subjects_to_stack()\n\nuse_certificate_chain_file\nSSL_use_certificate_file\nSSL_CTX_use_certificate_file\nSSL_use_PrivateKey_file\nSSL_CTX_use_PrivateKey_file\nSSL_CTX_use_serverinfo_file\n\nSSL_use_RSAPrivateKey_file\nSSL_CTX_use_RSAPrivateKey_file\n```\n\nNote that while the vulnerability is also exploitable through the use of the command line tool `openssl asn1parse`, the vulnerability's DoS impact in this case does not pose a threat, since the DoS will crash the forked `openssl` tool process only",
                "markdown": "The scanner checks if at least one of the vulnerable functions is called:\n```\nPEM_read_bio_ex()\nPEM_read_bio()\nPEM_read()\nPEM_read_DHparams()\nPEM_read_PrivateKey()\nPEM_read_bio_PrivateKey()\nPEM_read_RSA_PUBKEY()\nPEM_read_bio_RSA_PUBKEY()\nPEM_read_RSAPrivateKey()\nPEM_read_bio_RSAPrivateKey()\nPEM_read_PKCS7()\nPEM_read_bio_PKCS7()\nPEM_read_X509()\nPEM_read_bio_X509()\nPEM_read_X509_AUX()\nPEM_read_bio_X509_AUX()\nPEM_read_X509_CRL()\nPEM_read_bio_X509_CRL()\nPEM_read_bio_X509_REQ()\nPEM_read_bio_ECPrivateKey()\nPEM_read_bio_PKCS8()\n\nPEM_X509_INFO_read_bio_ex()\nSSL_CTX_use_serverinfo_file()\nSSL_use_cert_and_key() \nSSL_CTX_use_certificate_chain_file()\nSSL_CTX_load_verify_locations()\nSSL_CTX_set1_verify_file()\nSSL_CTX_set1_verify_path()\nX509_LOOKUP_load_file()\n\nSSL_load_client_CA_file_ex()\nSSL_load_client_CA_file()\nSSL_add_file_cert_subjects_to_stack()\nSSL_add_dir_cert_subjects_to_stack()\nSSL_add_store_cert_subjects_to_stack()\n\nuse_certificate_chain_file\nSSL_use_certificate_file\nSSL_CTX_use_certificate_file\nSSL_use_PrivateKey_file\nSSL_CTX_use_PrivateKey_file\nSSL_CTX_use_serverinfo_file\n\nSSL_use_RSAPrivateKey_file\nSSL_CTX_use_RSAPrivateKey_file\n```\n\nNote that while the vulnerability is also exploitable through the use of the command line tool `openssl asn1parse`, the vulnerability's DoS impact in this case does not pose a threat, since the DoS will crash the forked `openssl` tool process only"
              },
              "properties": {
                "applicability": "not_applicable",
                "conclusion": "positive",
                "security-severity": "6.9"
              }
            },
            {
              "id": "applic_CVE-2023-0215",
              "name": "CVE-2023-0215",
              "shortDescription": {
                "text": "Scanner for CVE-2023-0215"
              },
              "fullDescription": {
                "text": "The scanner checks if at least one of the vulnerable functions is called:\n```\nPEM_write_bio_ASN1_stream()\nPEM_write_bio_CMS_stream()\nPEM_write_bio_PKCS7_stream()\nSMIME_write_ASN1()\nSMIME_write_CMS()\nSMIME_write_PKCS7()\nBIO_new_CMS()\nBIO_new_PKCS7()\ni2d_CMS_bio_stream()\ni2d_PKCS7_bio_stream()\ni2d_ASN1_bio_stream()\nBIO_new_NDEF()\n```",
                "markdown": "The scanner checks if at least one of the vulnerable functions is called:\n```\nPEM_write_bio_ASN1_stream()\nPEM_write_bio_CMS_stream()\nPEM_write_bio_PKCS7_stream()\nSMIME_write_ASN1()\nSMIME_write_CMS()\nSMIME_write_PKCS7()\nBIO_new_CMS()\nBIO_new_PKCS7()\ni2d_CMS_bio_stream()\ni2d_PKCS7_bio_stream()\ni2d_ASN1_bio_stream()\nBIO_new_NDEF()\n```"
              },
              "properties": {
                "applicability": "not_applicable",
                "conclusion": "positive",
                "security-severity": "6.9"
              }
            },
            {
              "id": "applic_CVE-2023-0217",
              "name": "CVE-2023-0217",
              "shortDescription": {
                "text": "Scanner for CVE-2023-0217"
              },
              "fullDescription": {
                "text": "When checking ELF files, the scanner checks whether the vulnerable `EVP_PKEY_public_check()` function is called.\n\nNote that the CVE is never applicable in Python, since the vulnerable functions cannot be externally invoked",
                "markdown": "When checking ELF files, the scanner checks whether the vulnerable `EVP_PKEY_public_check()` function is called.\n\nNote that the CVE is never applicable in Python, since the vulnerable functions cannot be externally invoked"
              },
              "properties": {
                "applicability": "not_applicable",
                "conclusion": "positive",
                "security-severity": "6.9"
              }
            },
            {
              "id": "applic_CVE-2023-0286",
              "name": "CVE-2023-0286",
              "shortDescription": {
                "text": "Scanner for CVE-2023-0286"
              },
              "fullDescription": {
                "text": "The scanner checks if at least one of the vulnerable API calls is called:\n\n* `X509_STORE_CTX_get_check_revocation`\n* `X509_STORE_get_check_revocation`\n\nFor determining the applicability of this CVE, an additional condition (that the scanner currently does not check) should be verified: The CRL checking option must also be enabled.",
                "markdown": "The scanner checks if at least one of the vulnerable API calls is called:\n\n* `X509_STORE_CTX_get_check_revocation`\n* `X509_STORE_get_check_revocation`\n\nFor determining the applicability of this CVE, an additional condition (that the scanner currently does not check) should be verified: The CRL checking option must also be enabled."
              },
              "properties": {
                "applicability": "not_applicable",
                "conclusion": "positive",
                "security-severity": "6.9"
              }
            },
            {
              "id": "applic_CVE-2023-0401",
              "name": "CVE-2023-0401",
              "shortDescription": {
                "text": "Scanner for CVE-2023-0401"
              },
              "fullDescription": {
                "text": "When checking ELF files, the scanner checks whether at least one of the vulnerable API calls is called:\n\n* `PKCS7_decrypt`\n* `PKCS7_dataInit`\n\nNote that the CVE is never applicable in Python, since the vulnerable functions cannot be externally invoked",
                "markdown": "When checking ELF files, the scanner checks whether at least one of the vulnerable API calls is called:\n\n* `PKCS7_decrypt`\n* `PKCS7_dataInit`\n\nNote that the CVE is never applicable in Python, since the vulnerable functions cannot be externally invoked"
              },
              "properties": {
                "applicability": "not_applicable",
                "conclusion": "positive",
                "security-severity": "6.9"
              }
            },
            {
              "id": "applic_CVE-2022-23491",
              "name": "CVE-2022-23491",
              "shortDescription": {
                "text": "Scanner for CVE-2022-23491"
              },
              "fullDescription": {
                "text": "The scanner checks whether the vulnerable function `certifi.where()` is called, or if any of the following functions are called with the `verify` argument set to false:\n\n* `requests.get()` \n* `requests.options()`\n* `requests.head()`\n* `requests.post()`\n* `requests.put()`\n* `requests.patch()`\n* `requests.delete()`",
                "markdown": "The scanner checks whether the vulnerable function `certifi.where()` is called, or if any of the following functions are called with the `verify` argument set to false:\n\n* `requests.get()` \n* `requests.options()`\n* `requests.head()`\n* `requests.post()`\n* `requests.put()`\n* `requests.patch()`\n* `requests.delete()`"
              },
              "properties": {
                "applicability": "not_applicable",
                "conclusion": "positive",
                "security-severity": "6.9"
              }
            },
            {
              "id": "applic_CVE-2023-37920",
              "name": "CVE-2023-37920",
              "shortDescription": {
                "text": "Scanner for CVE-2023-37920"
              },
              "fullDescription": {
                "text": "The scanner checks whether the vulnerable function `certifi.where()` is called, or if any of the following functions are called with the `verify` argument set to false:\n\n* `requests.get()` \n* `requests.options()`\n* `requests.head()`\n* `requests.post()`\n* `requests.put()`\n* `requests.patch()`\n* `requests.delete()`",
                "markdown": "The scanner checks whether the vulnerable function `certifi.where()` is called, or if any of the following functions are called with the `verify` argument set to false:\n\n* `requests.get()` \n* `requests.options()`\n* `requests.head()`\n* `requests.post()`\n* `requests.put()`\n* `requests.patch()`\n* `requests.delete()`"
              },
              "properties": {
                "applicability": "not_applicable",
                "conclusion": "positive",
                "security-severity": "6.9"
              }
            },
            {
              "id": "applic_CVE-2023-32681",
              "name": "CVE-2023-32681",
              "shortDescription": {
                "text": "Scanner for CVE-2023-32681"
              },
              "fullDescription": {
                "text": "The scanner checks for any of the following usages of the library `requests`.\nCalls for the vulnerable function:\n\n* `requests.Session.rebuild_proxies`\n\nOr, calls for the following vulnerable functions that have the `proxies` argument, but not the `allow_redirects` argument set to false:\n\n* `requests.request`\n* `requests.get`\n* `requests.options`\n* `requests.head`\n* `requests.post`\n* `requests.put`\n* `requests.patch`\n* `requests.delete`\n* `requests.send`\n* `requests.Session.request`\n* `requests.Session.get`\n* `requests.Session.options`\n* `requests.Session.head`\n* `requests.Session.post`\n* `requests.Session.put`\n* `requests.Session.patch`\n* `requests.Session.delete`\n* `requests.Session.send`\n\nFor determining the applicability of this CVE, an additional condition (that the scanner currently does not check) should be verified: the proxy should have authorization information in its URL (e.g. `https://username:password@proxy:8080`).",
                "markdown": "The scanner checks for any of the following usages of the library `requests`.\nCalls for the vulnerable function:\n\n* `requests.Session.rebuild_proxies`\n\nOr, calls for the following vulnerable functions that have the `proxies` argument, but not the `allow_redirects` argument set to false:\n\n* `requests.request`\n* `requests.get`\n* `requests.options`\n* `requests.head`\n* `requests.post`\n* `requests.put`\n* `requests.patch`\n* `requests.delete`\n* `requests.send`\n* `requests.Session.request`\n* `requests.Session.get`\n* `requests.Session.options`\n* `requests.Session.head`\n* `requests.Session.post`\n* `requests.Session.put`\n* `requests.Session.patch`\n* `requests.Session.delete`\n* `requests.Session.send`\n\nFor determining the applicability of this CVE, an additional condition (that the scanner currently does not check) should be verified: the proxy should have authorization information in its URL (e.g. `https://username:password@proxy:8080`)."
              },
              "properties": {
                "applicability": "not_applicable",
                "conclusion": "positive",
                "security-severity": "6.9"
              }
            },
            {
              "id": "applic_CVE-2023-43804",
              "name": "CVE-2023-43804",
              "shortDescription": {
                "text": "Scanner for CVE-2023-43804"
              },
              "fullDescription": {
                "text": "The scanner checks whether any of the following vulnerable functions are called, with a `headers` argument and `redirect` argument is not set to `False`:\n\n* `urllib3.request()`\n* `urllib3.request_encode_url()`\n* `urllib3.request_encode_body()`\n* `urllib3.urlopen()`\n* `urllib3.PoolManager().request()`\n* `urllib3.PoolManager().request_encode_url()`\n* `urllib3.PoolManager().request_encode_body()`\n* `urllib3.PoolManager().urlopen()`",
                "markdown": "The scanner checks whether any of the following vulnerable functions are called, with a `headers` argument and `redirect` argument is not set to `False`:\n\n* `urllib3.request()`\n* `urllib3.request_encode_url()`\n* `urllib3.request_encode_body()`\n* `urllib3.urlopen()`\n* `urllib3.PoolManager().request()`\n* `urllib3.PoolManager().request_encode_url()`\n* `urllib3.PoolManager().request_encode_body()`\n* `urllib3.PoolManager().urlopen()`"
              },
              "properties": {
                "applicability": "not_applicable",
                "conclusion": "positive",
                "security-severity": "6.9"
              }
            },
            {
              "id": "applic_CVE-2022-1941",
              "name": "CVE-2022-1941",
              "shortDescription": {
                "text": "Scanner for CVE-2022-1941"
              },
              "fullDescription": {
                "text": "For C++:\nThe scanner checks whether one of the functions `ParseFromString()` or `ParseFromIstream()` is called.\n\nFor Python:\nThe scanner checks whether the vulnerable function `ParseFromString()` is called.\n\nNote: The scanner does not check whether the vulnerable option `message_set_wire_format` is `true` in .proto files (precompiled protobuf files), an additional condition for this vulnerability to be applicable.",
                "markdown": "For C++:\nThe scanner checks whether one of the functions `ParseFromString()` or `ParseFromIstream()` is called.\n\nFor Python:\nThe scanner checks whether the vulnerable function `ParseFromString()` is called.\n\nNote: The scanner does not check whether the vulnerable option `message_set_wire_format` is `true` in .proto files (precompiled protobuf files), an additional condition for this vulnerability to be applicable."
              },
              "properties": {
                "applicability": "not_applicable",
                "conclusion": "positive",
                "security-severity": "6.9"
              }
            },
            {
              "id": "applic_CVE-2023-0216",
              "name": "CVE-2023-0216",
              "shortDescription": {
                "text": "Scanner for CVE-2023-0216"
              },
              "fullDescription": {
                "text": "When checking ELF files, the scanner checks if at least one of the vulnerable functions is called:\n\n* `d2i_PKCS7()`\n* `d2i_PKCS7_bio()`\n* `d2i_PKCS7_fp()`\n\nWhen checking Python files, the scanner checks if at least one of the vulnerable functions is called with external input to its 1st (`bytes`) argument:\n\n* `cryptography.hazmat.primitives.serialization.pkcs7.load_der_pkcs7_certificates`\n* `cryptography.hazmat.primitives.serialization.pkcs7.load_pem_pkcs7_certificates`",
                "markdown": "When checking ELF files, the scanner checks if at least one of the vulnerable functions is called:\n\n* `d2i_PKCS7()`\n* `d2i_PKCS7_bio()`\n* `d2i_PKCS7_fp()`\n\nWhen checking Python files, the scanner checks if at least one of the vulnerable functions is called with external input to its 1st (`bytes`) argument:\n\n* `cryptography.hazmat.primitives.serialization.pkcs7.load_der_pkcs7_certificates`\n* `cryptography.hazmat.primitives.serialization.pkcs7.load_pem_pkcs7_certificates`"
              },
              "properties": {
                "applicability": "not_applicable",
                "conclusion": "positive",
                "security-severity": "6.9"
              }
            },
            {
              "id": "applic_CVE-2023-2650",
              "name": "CVE-2023-2650",
              "shortDescription": {
                "text": "Scanner for CVE-2023-2650"
              },
              "fullDescription": {
                "text": "When checking ELF files, the scanner checks whether one of the following function is called with an external input:\n\n* Direct call to `OBJ_obj2txt()` function (for OpenSSL 1.x and OpenSSL 3.x)\n\n**Only for OpenSSL 3.x:**\n\n* OCSP: `OCSP_basic_verify()`\n\n* PKCS7/SMIME:\n`PKCS7_decrypt()`\n`PKCS7_sign()`\n`PKCS7_verify()`\n\n* CMS:\n`CMS_EncryptedData_decrypt()`\n`CMS_EncryptedData_encrypt()`\n`CMS_EnvelopedData_decrypt()`\n`CMS_final()`\n`CMS_decrypt_set1_password()`\n`CMS_RecipientInfo_decrypt()`\n`CMS_decrypt()`\n`CMS_decrypt_set1_pkey()`\n`CMS_decrypt_set1_pkey_and_peer()`\n`CMS_SignedData_verify()`\n`CMS_verify()`\n`CMS_SignerInfo_verify()`\n`CMS_compress()`\n`CMS_data_create()`\n`CMS_data_create_ex()`\n`CMS_digest_create()`\n`CMS_digest_create_ex()`\n`CMS_digest_verify()`\n`CMS_encrypt()`\n`CMS_encrypt_ex()`\n`CMS_final_digest()`\n`CMS_sign()`\n`CMS_sign_ex()`\n`CMS_add1_signer()`\n`CMS_sign_receipt()`\n`CMS_uncompress()`\n`CMS_verify_receipt()`\n\n* CMP/CRMF:\n`OSSL_CMP_get_caCerts()`\n`OSSL_CRMF_ENCRYPTEDVALUE_get1_encCert()`\n`OSSL_CRMF_pbm_new()`\n\n* TS:\n`TS_REQ_print_bio()`\n`TS_OBJ_print_bio()`\n`TS_RESP_create_response()`\n`TS_RESP_print_bio()`\n`TS_RESP_verify_response()`\n`TS_RESP_verify_token()`\n\n* ASN1:\n`ASN1_parse()`\n`X509_NAME_print_ex()`\n`X509_NAME_print_ex_fp()`\n`d2i_AutoPrivateKey()`\n`d2i_PrivateKey()`\n`X509_STORE_CTX_print_verify_cb()`\n`x509_pubkey_ex_d2i_ex()`\n\n* EVP:\n`EVP_PKCS82PKEY()`\n`EVP_PKCS82PKEY_ex()`\n`PKCS5_v2_PBE_keyivgen()`\n`PKCS5_v2_PBE_keyivgen_ex()`\n\n* ESS:\n`OSSL_ESS_check_signing_certs()`\n\nNote that the CVE is never applicable in Python, since the vulnerable functions cannot be externally invoked",
                "markdown": "When checking ELF files, the scanner checks whether one of the following function is called with an external input:\n\n* Direct call to `OBJ_obj2txt()` function (for OpenSSL 1.x and OpenSSL 3.x)\n\n**Only for OpenSSL 3.x:**\n\n* OCSP: `OCSP_basic_verify()`\n\n* PKCS7/SMIME:\n`PKCS7_decrypt()`\n`PKCS7_sign()`\n`PKCS7_verify()`\n\n* CMS:\n`CMS_EncryptedData_decrypt()`\n`CMS_EncryptedData_encrypt()`\n`CMS_EnvelopedData_decrypt()`\n`CMS_final()`\n`CMS_decrypt_set1_password()`\n`CMS_RecipientInfo_decrypt()`\n`CMS_decrypt()`\n`CMS_decrypt_set1_pkey()`\n`CMS_decrypt_set1_pkey_and_peer()`\n`CMS_SignedData_verify()`\n`CMS_verify()`\n`CMS_SignerInfo_verify()`\n`CMS_compress()`\n`CMS_data_create()`\n`CMS_data_create_ex()`\n`CMS_digest_create()`\n`CMS_digest_create_ex()`\n`CMS_digest_verify()`\n`CMS_encrypt()`\n`CMS_encrypt_ex()`\n`CMS_final_digest()`\n`CMS_sign()`\n`CMS_sign_ex()`\n`CMS_add1_signer()`\n`CMS_sign_receipt()`\n`CMS_uncompress()`\n`CMS_verify_receipt()`\n\n* CMP/CRMF:\n`OSSL_CMP_get_caCerts()`\n`OSSL_CRMF_ENCRYPTEDVALUE_get1_encCert()`\n`OSSL_CRMF_pbm_new()`\n\n* TS:\n`TS_REQ_print_bio()`\n`TS_OBJ_print_bio()`\n`TS_RESP_create_response()`\n`TS_RESP_print_bio()`\n`TS_RESP_verify_response()`\n`TS_RESP_verify_token()`\n\n* ASN1:\n`ASN1_parse()`\n`X509_NAME_print_ex()`\n`X509_NAME_print_ex_fp()`\n`d2i_AutoPrivateKey()`\n`d2i_PrivateKey()`\n`X509_STORE_CTX_print_verify_cb()`\n`x509_pubkey_ex_d2i_ex()`\n\n* EVP:\n`EVP_PKCS82PKEY()`\n`EVP_PKCS82PKEY_ex()`\n`PKCS5_v2_PBE_keyivgen()`\n`PKCS5_v2_PBE_keyivgen_ex()`\n\n* ESS:\n`OSSL_ESS_check_signing_certs()`\n\nNote that the CVE is never applicable in Python, since the vulnerable functions cannot be externally invoked"
              },
              "properties": {
                "applicability": "not_applicable",
                "conclusion": "positive",
                "security-severity": "6.9"
              }
            },
            {
              "id": "applic_CVE-2021-33503",
              "name": "CVE-2021-33503",
              "shortDescription": {
                "text": "Scanner for CVE-2021-33503"
              },
              "fullDescription": {
                "text": "The scanner checks if any of these vulnerable functions are called with user input:\n\n- `urllib3.HTTPConnectionPool.connection_from_url`\n- `urllib3.HTTPConnectionPool.is_same_host`\n- `urllib3.HTTPConnectionPool.urlopen`\n- `urllib3.PoolManager.connection_from_url`\n- `urllib3.PoolManager.urlopen`\n- `urllib3.ProxyManager._set_proxy_headers`\n- `urllib3.ProxyManager`\n- `urllib3.ProxyManager.urlopen`\n- `urllib3.RequestMethods.request`\n- `urllib3.RequestMethods.request_encode_body`\n- `urllib3.RequestMethods.request_encode_url`\n- `urllib3.contrib.socks.SOCKSProxyManager`\n- `urllib3.util.url.get_host`\n- `urllib3.util.url.parse_url`",
                "markdown": "The scanner checks if any of these vulnerable functions are called with user input:\n\n- `urllib3.HTTPConnectionPool.connection_from_url`\n- `urllib3.HTTPConnectionPool.is_same_host`\n- `urllib3.HTTPConnectionPool.urlopen`\n- `urllib3.PoolManager.connection_from_url`\n- `urllib3.PoolManager.urlopen`\n- `urllib3.ProxyManager._set_proxy_headers`\n- `urllib3.ProxyManager`\n- `urllib3.ProxyManager.urlopen`\n- `urllib3.RequestMethods.request`\n- `urllib3.RequestMethods.request_encode_body`\n- `urllib3.RequestMethods.request_encode_url`\n- `urllib3.contrib.socks.SOCKSProxyManager`\n- `urllib3.util.url.get_host`\n- `urllib3.util.url.parse_url`"
              },
              "properties": {
                "applicability": "not_applicable",
                "conclusion": "positive",
                "security-severity": "6.9"
              }
            },
            {
              "id": "applic_CVE-2023-49083",
              "name": "CVE-2023-49083",
              "shortDescription": {
                "text": "Scanner for CVE-2023-49083"
              },
              "fullDescription": {
                "text": "The scanner checks whether the following vulnerable functions are called with external input:\n\n* `cryptography.hazmat.primitives.serialization.pkcs7.load_pem_pkcs7_certificates`\n* `cryptography.hazmat.primitives.serialization.pkcs7.load_der_pkcs7_certificates`",
                "markdown": "The scanner checks whether the following vulnerable functions are called with external input:\n\n* `cryptography.hazmat.primitives.serialization.pkcs7.load_pem_pkcs7_certificates`\n* `cryptography.hazmat.primitives.serialization.pkcs7.load_der_pkcs7_certificates`"
              },
              "properties": {
                "applicability": "not_applicable",
                "conclusion": "positive",
                "security-severity": "6.9"
              }
            },
            {
              "id": "applic_CVE-2023-50782",
              "name": "CVE-2023-50782",
              "shortDescription": {
                "text": "Scanner for CVE-2023-50782"
              },
              "fullDescription": {
                "text": "The scanner checks whether the PKCS1v15 vulnerable padding is used in a decryption function.",
                "markdown": "The scanner checks whether the PKCS1v15 vulnerable padding is used in a decryption function."
              },
              "properties": {
                "applicability": "not_applicable",
                "conclusion": "positive",
                "security-severity": "6.9"
              }
            },
            {
              "id": "applic_CVE-2021-3572",
              "name": "CVE-2021-3572",
              "shortDescription": {
                "text": "Scanner for uncovered CVE-2021-3572"
              },
              "fullDescription": {
                "text": "",
                "markdown": ""
              },
              "properties": {
                "applicability": "not_covered"
              }
            },
            {
              "id": "applic_CVE-2023-5752",
              "name": "CVE-2023-5752",
              "shortDescription": {
                "text": "Scanner for uncovered CVE-2023-5752"
              },
              "fullDescription": {
                "text": "",
                "markdown": ""
              },
              "properties": {
                "applicability": "not_covered"
              }
            },
            {
              "id": "applic_CVE-2021-22570",
              "name": "CVE-2021-22570",
              "shortDescription": {
                "text": "Scanner for uncovered CVE-2021-22570"
              },
              "fullDescription": {
                "text": "",
                "markdown": ""
              },
              "properties": {
                "applicability": "not_covered"
              }
            },
            {
              "id": "applic_CVE-2020-25658",
              "name": "CVE-2020-25658",
              "shortDescription": {
                "text": "Scanner for uncovered CVE-2020-25658"
              },
              "fullDescription": {
                "text": "",
                "markdown": ""
              },
              "properties": {
                "applicability": "not_covered"
              }
            },
            {
              "id": "applic_CVE-2022-40899",
              "name": "CVE-2022-40899",
              "shortDescription": {
                "text": "Scanner for uncovered CVE-2022-40899"
              },
              "fullDescription": {
                "text": "",
                "markdown": ""
              },
              "properties": {
                "applicability": "not_covered"
              }
            },
            {
              "id": "applic_CVE-2023-3446",
              "name": "CVE-2023-3446",
              "shortDescription": {
                "text": "Scanner for uncovered CVE-2023-3446"
              },
              "fullDescription": {
                "text": "",
                "markdown": ""
              },
              "properties": {
                "applicability": "not_covered"
              }
            },
            {
              "id": "applic_CVE-2024-35195",
              "name": "CVE-2024-35195",
              "shortDescription": {
                "text": "Scanner for uncovered CVE-2024-35195"
              },
              "fullDescription": {
                "text": "",
                "markdown": ""
              },
              "properties": {
                "applicability": "not_covered"
              }
            },
            {
              "id": "applic_CVE-2022-4203",
              "name": "CVE-2022-4203",
              "shortDescription": {
                "text": "Scanner for uncovered CVE-2022-4203"
              },
              "fullDescription": {
                "text": "The scanner checks whether the `SSL_CTX_set_verify()` or `SSL_set_verify()` functions are called.\nA call with the `SSL_VERIFY_PEER` mode is enabling client authentication and makes this vulnerability possible.",
                "markdown": "The scanner checks whether the `SSL_CTX_set_verify()` or `SSL_set_verify()` functions are called.\nA call with the `SSL_VERIFY_PEER` mode is enabling client authentication and makes this vulnerability possible."
              },
              "properties": {
                "applicability": "not_covered"
              }
            },
            {
              "id": "applic_CVE-2023-45803",
              "name": "CVE-2023-45803",
              "shortDescription": {
                "text": "Scanner for uncovered CVE-2023-45803"
              },
              "fullDescription": {
                "text": "",
                "markdown": ""
              },
              "properties": {
                "applicability": "not_covered"
              }
            },
            {
              "id": "applic_CVE-2018-20225",
              "name": "CVE-2018-20225",
              "shortDescription": {
                "text": "Scanner for uncovered CVE-2018-20225"
              },
              "fullDescription": {
                "text": "",
                "markdown": ""
              },
              "properties": {
                "applicability": "not_covered"
              }
            },
            {
              "id": "applic_CVE-2021-32749",
              "name": "CVE-2021-32749",
              "shortDescription": {
                "text": "Scanner for uncovered CVE-2021-32749"
              },
              "fullDescription": {
                "text": "",
                "markdown": ""
              },
              "properties": {
                "applicability": "not_covered"
              }
            },
            {
              "id": "applic_CVE-2021-21240",
              "name": "CVE-2021-21240",
              "shortDescription": {
                "text": "Scanner for uncovered CVE-2021-21240"
              },
              "fullDescription": {
                "text": "",
                "markdown": ""
              },
              "properties": {
                "applicability": "not_covered"
              }
            },
            {
              "id": "applic_CVE-2023-29483",
              "name": "CVE-2023-29483",
              "shortDescription": {
                "text": "Scanner for uncovered CVE-2023-29483"
              },
              "fullDescription": {
                "text": "",
                "markdown": ""
              },
              "properties": {
                "applicability": "not_covered"
              }
            },
            {
              "id": "applic_CVE-2020-22083",
              "name": "CVE-2020-22083",
              "shortDescription": {
                "text": "Scanner for uncovered CVE-2020-22083"
              },
              "fullDescription": {
                "text": "",
                "markdown": ""
              },
              "properties": {
                "applicability": "not_covered"
              }
            },
            {
              "id": "applic_CVE-2023-26112",
              "name": "CVE-2023-26112",
              "shortDescription": {
                "text": "Scanner for uncovered CVE-2023-26112"
              },
              "fullDescription": {
                "text": "",
                "markdown": ""
              },
              "properties": {
                "applicability": "not_covered"
              }
            },
            {
              "id": "applic_CVE-2020-36242",
              "name": "CVE-2020-36242",
              "shortDescription": {
                "text": "Scanner for uncovered CVE-2020-36242"
              },
              "fullDescription": {
                "text": "",
                "markdown": ""
              },
              "properties": {
                "applicability": "not_covered"
              }
            },
            {
              "id": "applic_CVE-2022-4304",
              "name": "CVE-2022-4304",
              "shortDescription": {
                "text": "Scanner for uncovered CVE-2022-4304"
              },
              "fullDescription": {
                "text": "",
                "markdown": ""
              },
              "properties": {
                "applicability": "not_covered"
              }
            },
            {
              "id": "applic_CVE-2023-23931",
              "name": "CVE-2023-23931",
              "shortDescription": {
                "text": "Scanner for uncovered CVE-2023-23931"
              },
              "fullDescription": {
                "text": "",
                "markdown": ""
              },
              "properties": {
                "applicability": "not_covered"
              }
            },
            {
              "id": "applic_CVE-2024-0727",
              "name": "CVE-2024-0727",
              "shortDescription": {
                "text": "Scanner for uncovered CVE-2024-0727"
              },
              "fullDescription": {
                "text": "",
                "markdown": ""
              },
              "properties": {
                "applicability": "not_covered"
              }
            }
          ],
          "version": "1.0"
        }
      },
      "invocations": [
        {
          "arguments": [
            "/root/.jfrog/dependencies/analyzerManager/jas_scanner/jas_scanner",
            "scan",
            "/tmp/jfrog.cli.temp.-1718663484-2820551762/config.yaml"
          ],
          "executionSuccessful": true,
          "workingDirectory": {
            "uri": "/tmp/jfrog.cli.temp.-1718663408-3727193563/image.tar"
          }
        }
      ],
      "results": [
        {
          "ruleId": "applic_CVE-2020-14343",
          "kind": "pass",
          "message": {
            "text": "The scanner checks whether any of the following vulnerable functions are called:\n\n-  `yaml.full_load()`\n-  `yaml.load()` only unsafe calls (without specifying `SafeLoader` as the `Loader`class)."
          }
        },
        {
          "ruleId": "applic_CVE-2022-3996",
          "kind": "pass",
          "message": {
            "text": "The vulnerability is only exploitable when running under the Windows OS.\nSince currently only Linux containers are supported, the scanner will always conclude that this vulnerability is not applicable."
          }
        },
        {
          "ruleId": "applic_CVE-2023-4807",
          "kind": "pass",
          "message": {
            "text": "The vulnerability is only exploitable when running under the Windows OS.\nSince currently only Linux containers are supported, the scanner will always conclude that this vulnerability is not applicable."
          }
        },
        {
          "ruleId": "applic_CVE-2022-40897",
          "kind": "pass",
          "message": {
            "text": "The scanner checks whether the vulnerable function `find_external_links` is called.\n\nNote that the scanner does not check for an additional vulnerable case in which the `pip` CLI tool is executed with the  `--editable` flag. In this case, the vulnerability will lead to a DoS of a forked command-line utility, which has a minimal security impact."
          }
        },
        {
          "ruleId": "applic_CVE-2022-4450",
          "kind": "pass",
          "message": {
            "text": "The scanner checks if at least one of the vulnerable functions is called:\n```\nPEM_read_bio_ex()\nPEM_read_bio()\nPEM_read()\nPEM_read_DHparams()\nPEM_read_PrivateKey()\nPEM_read_bio_PrivateKey()\nPEM_read_RSA_PUBKEY()\nPEM_read_bio_RSA_PUBKEY()\nPEM_read_RSAPrivateKey()\nPEM_read_bio_RSAPrivateKey()\nPEM_read_PKCS7()\nPEM_read_bio_PKCS7()\nPEM_read_X509()\nPEM_read_bio_X509()\nPEM_read_X509_AUX()\nPEM_read_bio_X509_AUX()\nPEM_read_X509_CRL()\nPEM_read_bio_X509_CRL()\nPEM_read_bio_X509_REQ()\nPEM_read_bio_ECPrivateKey()\nPEM_read_bio_PKCS8()\n\nPEM_X509_INFO_read_bio_ex()\nSSL_CTX_use_serverinfo_file()\nSSL_use_cert_and_key() \nSSL_CTX_use_certificate_chain_file()\nSSL_CTX_load_verify_locations()\nSSL_CTX_set1_verify_file()\nSSL_CTX_set1_verify_path()\nX509_LOOKUP_load_file()\n\nSSL_load_client_CA_file_ex()\nSSL_load_client_CA_file()\nSSL_add_file_cert_subjects_to_stack()\nSSL_add_dir_cert_subjects_to_stack()\nSSL_add_store_cert_subjects_to_stack()\n\nuse_certificate_chain_file\nSSL_use_certificate_file\nSSL_CTX_use_certificate_file\nSSL_use_PrivateKey_file\nSSL_CTX_use_PrivateKey_file\nSSL_CTX_use_serverinfo_file\n\nSSL_use_RSAPrivateKey_file\nSSL_CTX_use_RSAPrivateKey_file\n```\n\nNote that while the vulnerability is also exploitable through the use of the command line tool `openssl asn1parse`, the vulnerability's DoS impact in this case does not pose a threat, since the DoS will crash the forked `openssl` tool process only"
          }
        },
        {
          "ruleId": "applic_CVE-2023-0215",
          "kind": "pass",
          "message": {
            "text": "The scanner checks if at least one of the vulnerable functions is called:\n```\nPEM_write_bio_ASN1_stream()\nPEM_write_bio_CMS_stream()\nPEM_write_bio_PKCS7_stream()\nSMIME_write_ASN1()\nSMIME_write_CMS()\nSMIME_write_PKCS7()\nBIO_new_CMS()\nBIO_new_PKCS7()\ni2d_CMS_bio_stream()\ni2d_PKCS7_bio_stream()\ni2d_ASN1_bio_stream()\nBIO_new_NDEF()\n```"
          }
        },
        {
          "ruleId": "applic_CVE-2023-0217",
          "kind": "pass",
          "message": {
            "text": "When checking ELF files, the scanner checks whether the vulnerable `EVP_PKEY_public_check()` function is called.\n\nNote that the CVE is never applicable in Python, since the vulnerable functions cannot be externally invoked"
          }
        },
        {
          "ruleId": "applic_CVE-2023-0286",
          "kind": "pass",
          "message": {
            "text": "The scanner checks if at least one of the vulnerable API calls is called:\n\n* `X509_STORE_CTX_get_check_revocation`\n* `X509_STORE_get_check_revocation`\n\nFor determining the applicability of this CVE, an additional condition (that the scanner currently does not check) should be verified: The CRL checking option must also be enabled."
          }
        },
        {
          "ruleId": "applic_CVE-2023-0401",
          "kind": "pass",
          "message": {
            "text": "When checking ELF files, the scanner checks whether at least one of the vulnerable API calls is called:\n\n* `PKCS7_decrypt`\n* `PKCS7_dataInit`\n\nNote that the CVE is never applicable in Python, since the vulnerable functions cannot be externally invoked"
          }
        },
        {
          "ruleId": "applic_CVE-2022-23491",
          "kind": "pass",
          "message": {
            "text": "The scanner checks whether the vulnerable function `certifi.where()` is called, or if any of the following functions are called with the `verify` argument set to false:\n\n* `requests.get()` \n* `requests.options()`\n* `requests.head()`\n* `requests.post()`\n* `requests.put()`\n* `requests.patch()`\n* `requests.delete()`"
          }
        },
        {
          "ruleId": "applic_CVE-2023-37920",
          "kind": "pass",
          "message": {
            "text": "The scanner checks whether the vulnerable function `certifi.where()` is called, or if any of the following functions are called with the `verify` argument set to false:\n\n* `requests.get()` \n* `requests.options()`\n* `requests.head()`\n* `requests.post()`\n* `requests.put()`\n* `requests.patch()`\n* `requests.delete()`"
          }
        },
        {
          "ruleId": "applic_CVE-2023-32681",
          "kind": "pass",
          "message": {
            "text": "The scanner checks for any of the following usages of the library `requests`.\nCalls for the vulnerable function:\n\n* `requests.Session.rebuild_proxies`\n\nOr, calls for the following vulnerable functions that have the `proxies` argument, but not the `allow_redirects` argument set to false:\n\n* `requests.request`\n* `requests.get`\n* `requests.options`\n* `requests.head`\n* `requests.post`\n* `requests.put`\n* `requests.patch`\n* `requests.delete`\n* `requests.send`\n* `requests.Session.request`\n* `requests.Session.get`\n* `requests.Session.options`\n* `requests.Session.head`\n* `requests.Session.post`\n* `requests.Session.put`\n* `requests.Session.patch`\n* `requests.Session.delete`\n* `requests.Session.send`\n\nFor determining the applicability of this CVE, an additional condition (that the scanner currently does not check) should be verified: the proxy should have authorization information in its URL (e.g. `https://username:password@proxy:8080`)."
          }
        },
        {
          "ruleId": "applic_CVE-2023-43804",
          "kind": "pass",
          "message": {
            "text": "The scanner checks whether any of the following vulnerable functions are called, with a `headers` argument and `redirect` argument is not set to `False`:\n\n* `urllib3.request()`\n* `urllib3.request_encode_url()`\n* `urllib3.request_encode_body()`\n* `urllib3.urlopen()`\n* `urllib3.PoolManager().request()`\n* `urllib3.PoolManager().request_encode_url()`\n* `urllib3.PoolManager().request_encode_body()`\n* `urllib3.PoolManager().urlopen()`"
          }
        },
        {
          "ruleId": "applic_CVE-2022-1941",
          "kind": "pass",
          "message": {
            "text": "For C++:\nThe scanner checks whether one of the functions `ParseFromString()` or `ParseFromIstream()` is called.\n\nFor Python:\nThe scanner checks whether the vulnerable function `ParseFromString()` is called.\n\nNote: The scanner does not check whether the vulnerable option `message_set_wire_format` is `true` in .proto files (precompiled protobuf files), an additional condition for this vulnerability to be applicable."
          }
        },
        {
          "ruleId": "applic_CVE-2023-0216",
          "kind": "pass",
          "message": {
            "text": "When checking ELF files, the scanner checks if at least one of the vulnerable functions is called:\n\n* `d2i_PKCS7()`\n* `d2i_PKCS7_bio()`\n* `d2i_PKCS7_fp()`\n\nWhen checking Python files, the scanner checks if at least one of the vulnerable functions is called with external input to its 1st (`bytes`) argument:\n\n* `cryptography.hazmat.primitives.serialization.pkcs7.load_der_pkcs7_certificates`\n* `cryptography.hazmat.primitives.serialization.pkcs7.load_pem_pkcs7_certificates`"
          }
        },
        {
          "ruleId": "applic_CVE-2023-2650",
          "kind": "pass",
          "message": {
            "text": "When checking ELF files, the scanner checks whether one of the following function is called with an external input:\n\n* Direct call to `OBJ_obj2txt()` function (for OpenSSL 1.x and OpenSSL 3.x)\n\n**Only for OpenSSL 3.x:**\n\n* OCSP: `OCSP_basic_verify()`\n\n* PKCS7/SMIME:\n`PKCS7_decrypt()`\n`PKCS7_sign()`\n`PKCS7_verify()`\n\n* CMS:\n`CMS_EncryptedData_decrypt()`\n`CMS_EncryptedData_encrypt()`\n`CMS_EnvelopedData_decrypt()`\n`CMS_final()`\n`CMS_decrypt_set1_password()`\n`CMS_RecipientInfo_decrypt()`\n`CMS_decrypt()`\n`CMS_decrypt_set1_pkey()`\n`CMS_decrypt_set1_pkey_and_peer()`\n`CMS_SignedData_verify()`\n`CMS_verify()`\n`CMS_SignerInfo_verify()`\n`CMS_compress()`\n`CMS_data_create()`\n`CMS_data_create_ex()`\n`CMS_digest_create()`\n`CMS_digest_create_ex()`\n`CMS_digest_verify()`\n`CMS_encrypt()`\n`CMS_encrypt_ex()`\n`CMS_final_digest()`\n`CMS_sign()`\n`CMS_sign_ex()`\n`CMS_add1_signer()`\n`CMS_sign_receipt()`\n`CMS_uncompress()`\n`CMS_verify_receipt()`\n\n* CMP/CRMF:\n`OSSL_CMP_get_caCerts()`\n`OSSL_CRMF_ENCRYPTEDVALUE_get1_encCert()`\n`OSSL_CRMF_pbm_new()`\n\n* TS:\n`TS_REQ_print_bio()`\n`TS_OBJ_print_bio()`\n`TS_RESP_create_response()`\n`TS_RESP_print_bio()`\n`TS_RESP_verify_response()`\n`TS_RESP_verify_token()`\n\n* ASN1:\n`ASN1_parse()`\n`X509_NAME_print_ex()`\n`X509_NAME_print_ex_fp()`\n`d2i_AutoPrivateKey()`\n`d2i_PrivateKey()`\n`X509_STORE_CTX_print_verify_cb()`\n`x509_pubkey_ex_d2i_ex()`\n\n* EVP:\n`EVP_PKCS82PKEY()`\n`EVP_PKCS82PKEY_ex()`\n`PKCS5_v2_PBE_keyivgen()`\n`PKCS5_v2_PBE_keyivgen_ex()`\n\n* ESS:\n`OSSL_ESS_check_signing_certs()`\n\nNote that the CVE is never applicable in Python, since the vulnerable functions cannot be externally invoked"
          }
        },
        {
          "ruleId": "applic_CVE-2021-33503",
          "kind": "pass",
          "message": {
            "text": "The scanner checks if any of these vulnerable functions are called with user input:\n\n- `urllib3.HTTPConnectionPool.connection_from_url`\n- `urllib3.HTTPConnectionPool.is_same_host`\n- `urllib3.HTTPConnectionPool.urlopen`\n- `urllib3.PoolManager.connection_from_url`\n- `urllib3.PoolManager.urlopen`\n- `urllib3.ProxyManager._set_proxy_headers`\n- `urllib3.ProxyManager`\n- `urllib3.ProxyManager.urlopen`\n- `urllib3.RequestMethods.request`\n- `urllib3.RequestMethods.request_encode_body`\n- `urllib3.RequestMethods.request_encode_url`\n- `urllib3.contrib.socks.SOCKSProxyManager`\n- `urllib3.util.url.get_host`\n- `urllib3.util.url.parse_url`"
          }
        },
        {
          "ruleId": "applic_CVE-2023-49083",
          "kind": "pass",
          "message": {
            "text": "The scanner checks whether the following vulnerable functions are called with external input:\n\n* `cryptography.hazmat.primitives.serialization.pkcs7.load_pem_pkcs7_certificates`\n* `cryptography.hazmat.primitives.serialization.pkcs7.load_der_pkcs7_certificates`"
          }
        },
        {
          "ruleId": "applic_CVE-2023-50782",
          "kind": "pass",
          "message": {
            "text": "The scanner checks whether the PKCS1v15 vulnerable padding is used in a decryption function."
          }
        }
      ]
    },
    {
      "tool": {
        "driver": {
          "informationUri": "https://jfrog.com/help/r/jfrog-security-documentation/jfrog-advanced-security",
          "name": "JFrog Secrets scanner",
          "rules": [
            {
              "id": "REQ.SECRET.GENERIC.TEXT",
              "name": "REQ.SECRET.GENERIC.TEXT",
              "shortDescription": {
                "text": "Scanner for REQ.SECRET.GENERIC.TEXT"
              },
              "fullDescription": {
                "text": "Storing hardcoded secrets in your source code or binary artifact could lead to several risks.\n\nIf the secret is associated with a wide scope of privileges, attackers could extract it from the source code or binary artifact and use it maliciously to attack many targets. For example, if the hardcoded password gives high-privilege access to an AWS account, the attackers may be able to query/modify company-wide sensitive data without per-user authentication.\n\n## Best practices\n\nUse safe storage when storing high-privilege secrets such as passwords and tokens, for example -\n\n* ### Environment Variables\n\nEnvironment variables are set outside of the application code, and can be dynamically passed to the application only when needed, for example -\n`SECRET_VAR=MySecret ./my_application`\nThis way, `MySecret` does not have to be hardcoded into `my_application`.\n\nNote that if your entire binary artifact is published (ex. a Docker container published to Docker Hub), the value for the environment variable must not be stored in the artifact itself (ex. inside the `Dockerfile` or one of the container's files) but rather must be passed dynamically, for example in the `docker run` call as an argument.\n\n* ### Secret management services\n\nExternal vendors offer cloud-based secret management services, that provide proper access control to each secret. The given access to each secret can be dynamically modified or even revoked. Some examples include -\n\n* [Hashicorp Vault](https://www.vaultproject.io)\n* [AWS KMS](https://aws.amazon.com/kms) (Key Management Service)\n* [Google Cloud KMS](https://cloud.google.com/security-key-management)\n\n## Least-privilege principle\n\nStoring a secret in a hardcoded manner can be made safer, by making sure the secret grants the least amount of privilege as needed by the application.\nFor example - if the application needs to read a specific table from a specific database, and the secret grants access to perform this operation **only** (meaning - no access to other tables, no write access at all) then the damage from any secret leaks is mitigated.\nThat being said, it is still not recommended to store secrets in a hardcoded manner, since this type of storage does not offer any way to revoke or moderate the usage of the secret.\n",
                "markdown": "Storing hardcoded secrets in your source code or binary artifact could lead to several risks.\n\nIf the secret is associated with a wide scope of privileges, attackers could extract it from the source code or binary artifact and use it maliciously to attack many targets. For example, if the hardcoded password gives high-privilege access to an AWS account, the attackers may be able to query/modify company-wide sensitive data without per-user authentication.\n\n## Best practices\n\nUse safe storage when storing high-privilege secrets such as passwords and tokens, for example -\n\n* ### Environment Variables\n\nEnvironment variables are set outside of the application code, and can be dynamically passed to the application only when needed, for example -\n`SECRET_VAR=MySecret ./my_application`\nThis way, `MySecret` does not have to be hardcoded into `my_application`.\n\nNote that if your entire binary artifact is published (ex. a Docker container published to Docker Hub), the value for the environment variable must not be stored in the artifact itself (ex. inside the `Dockerfile` or one of the container's files) but rather must be passed dynamically, for example in the `docker run` call as an argument.\n\n* ### Secret management services\n\nExternal vendors offer cloud-based secret management services, that provide proper access control to each secret. The given access to each secret can be dynamically modified or even revoked. Some examples include -\n\n* [Hashicorp Vault](https://www.vaultproject.io)\n* [AWS KMS](https://aws.amazon.com/kms) (Key Management Service)\n* [Google Cloud KMS](https://cloud.google.com/security-key-management)\n\n## Least-privilege principle\n\nStoring a secret in a hardcoded manner can be made safer, by making sure the secret grants the least amount of privilege as needed by the application.\nFor example - if the application needs to read a specific table from a specific database, and the secret grants access to perform this operation **only** (meaning - no access to other tables, no write access at all) then the damage from any secret leaks is mitigated.\nThat being said, it is still not recommended to store secrets in a hardcoded manner, since this type of storage does not offer any way to revoke or moderate the usage of the secret.\n"
              },
              "properties": {
                "applicability": "applicable",
                "conclusion": "negative",
                "security-severity": "6.9"
              }
            },
            {
              "id": "REQ.SECRET.GENERIC.CODE",
              "name": "REQ.SECRET.GENERIC.CODE",
              "shortDescription": {
                "text": "Scanner for REQ.SECRET.GENERIC.CODE"
              },
              "fullDescription": {
                "text": "Storing hardcoded secrets in your source code or binary artifact could lead to several risks.\n\nIf the secret is associated with a wide scope of privileges, attackers could extract it from the source code or binary artifact and use it maliciously to attack many targets. For example, if the hardcoded password gives high-privilege access to an AWS account, the attackers may be able to query/modify company-wide sensitive data without per-user authentication.\n\n## Best practices\n\nUse safe storage when storing high-privilege secrets such as passwords and tokens, for example -\n\n* ### Environment Variables\n\nEnvironment variables are set outside of the application code, and can be dynamically passed to the application only when needed, for example -\n`SECRET_VAR=MySecret ./my_application`\nThis way, `MySecret` does not have to be hardcoded into `my_application`.\n\nNote that if your entire binary artifact is published (ex. a Docker container published to Docker Hub), the value for the environment variable must not be stored in the artifact itself (ex. inside the `Dockerfile` or one of the container's files) but rather must be passed dynamically, for example in the `docker run` call as an argument.\n\n* ### Secret management services\n\nExternal vendors offer cloud-based secret management services, that provide proper access control to each secret. The given access to each secret can be dynamically modified or even revoked. Some examples include -\n\n* [Hashicorp Vault](https://www.vaultproject.io)\n* [AWS KMS](https://aws.amazon.com/kms) (Key Management Service)\n* [Google Cloud KMS](https://cloud.google.com/security-key-management)\n\n## Least-privilege principle\n\nStoring a secret in a hardcoded manner can be made safer, by making sure the secret grants the least amount of privilege as needed by the application.\nFor example - if the application needs to read a specific table from a specific database, and the secret grants access to perform this operation **only** (meaning - no access to other tables, no write access at all) then the damage from any secret leaks is mitigated.\nThat being said, it is still not recommended to store secrets in a hardcoded manner, since this type of storage does not offer any way to revoke or moderate the usage of the secret.\n",
                "markdown": "Storing hardcoded secrets in your source code or binary artifact could lead to several risks.\n\nIf the secret is associated with a wide scope of privileges, attackers could extract it from the source code or binary artifact and use it maliciously to attack many targets. For example, if the hardcoded password gives high-privilege access to an AWS account, the attackers may be able to query/modify company-wide sensitive data without per-user authentication.\n\n## Best practices\n\nUse safe storage when storing high-privilege secrets such as passwords and tokens, for example -\n\n* ### Environment Variables\n\nEnvironment variables are set outside of the application code, and can be dynamically passed to the application only when needed, for example -\n`SECRET_VAR=MySecret ./my_application`\nThis way, `MySecret` does not have to be hardcoded into `my_application`.\n\nNote that if your entire binary artifact is published (ex. a Docker container published to Docker Hub), the value for the environment variable must not be stored in the artifact itself (ex. inside the `Dockerfile` or one of the container's files) but rather must be passed dynamically, for example in the `docker run` call as an argument.\n\n* ### Secret management services\n\nExternal vendors offer cloud-based secret management services, that provide proper access control to each secret. The given access to each secret can be dynamically modified or even revoked. Some examples include -\n\n* [Hashicorp Vault](https://www.vaultproject.io)\n* [AWS KMS](https://aws.amazon.com/kms) (Key Management Service)\n* [Google Cloud KMS](https://cloud.google.com/security-key-management)\n\n## Least-privilege principle\n\nStoring a secret in a hardcoded manner can be made safer, by making sure the secret grants the least amount of privilege as needed by the application.\nFor example - if the application needs to read a specific table from a specific database, and the secret grants access to perform this operation **only** (meaning - no access to other tables, no write access at all) then the damage from any secret leaks is mitigated.\nThat being said, it is still not recommended to store secrets in a hardcoded manner, since this type of storage does not offer any way to revoke or moderate the usage of the secret.\n"
              },
              "properties": {
                "applicability": "not_applicable",
                "conclusion": "positive"
              }
            },
            {
              "id": "REQ.SECRET.GENERIC.URL",
              "name": "REQ.SECRET.GENERIC.URL",
              "shortDescription": {
                "text": "Scanner for REQ.SECRET.GENERIC.URL"
              },
              "fullDescription": {
                "text": "Storing hardcoded secrets in your source code or binary artifact could lead to several risks.\n\nIf the secret is associated with a wide scope of privileges, attackers could extract it from the source code or binary artifact and use it maliciously to attack many targets. For example, if the hardcoded password gives high-privilege access to an AWS account, the attackers may be able to query/modify company-wide sensitive data without per-user authentication.\n\n## Best practices\n\nUse safe storage when storing high-privilege secrets such as passwords and tokens, for example -\n\n* ### Environment Variables\n\nEnvironment variables are set outside of the application code, and can be dynamically passed to the application only when needed, for example -\n`SECRET_VAR=MySecret ./my_application`\nThis way, `MySecret` does not have to be hardcoded into `my_application`.\n\nNote that if your entire binary artifact is published (ex. a Docker container published to Docker Hub), the value for the environment variable must not be stored in the artifact itself (ex. inside the `Dockerfile` or one of the container's files) but rather must be passed dynamically, for example in the `docker run` call as an argument.\n\n* ### Secret management services\n\nExternal vendors offer cloud-based secret management services, that provide proper access control to each secret. The given access to each secret can be dynamically modified or even revoked. Some examples include -\n\n* [Hashicorp Vault](https://www.vaultproject.io)\n* [AWS KMS](https://aws.amazon.com/kms) (Key Management Service)\n* [Google Cloud KMS](https://cloud.google.com/security-key-management)\n\n## Least-privilege principle\n\nStoring a secret in a hardcoded manner can be made safer, by making sure the secret grants the least amount of privilege as needed by the application.\nFor example - if the application needs to read a specific table from a specific database, and the secret grants access to perform this operation **only** (meaning - no access to other tables, no write access at all) then the damage from any secret leaks is mitigated.\nThat being said, it is still not recommended to store secrets in a hardcoded manner, since this type of storage does not offer any way to revoke or moderate the usage of the secret.\n",
                "markdown": "Storing hardcoded secrets in your source code or binary artifact could lead to several risks.\n\nIf the secret is associated with a wide scope of privileges, attackers could extract it from the source code or binary artifact and use it maliciously to attack many targets. For example, if the hardcoded password gives high-privilege access to an AWS account, the attackers may be able to query/modify company-wide sensitive data without per-user authentication.\n\n## Best practices\n\nUse safe storage when storing high-privilege secrets such as passwords and tokens, for example -\n\n* ### Environment Variables\n\nEnvironment variables are set outside of the application code, and can be dynamically passed to the application only when needed, for example -\n`SECRET_VAR=MySecret ./my_application`\nThis way, `MySecret` does not have to be hardcoded into `my_application`.\n\nNote that if your entire binary artifact is published (ex. a Docker container published to Docker Hub), the value for the environment variable must not be stored in the artifact itself (ex. inside the `Dockerfile` or one of the container's files) but rather must be passed dynamically, for example in the `docker run` call as an argument.\n\n* ### Secret management services\n\nExternal vendors offer cloud-based secret management services, that provide proper access control to each secret. The given access to each secret can be dynamically modified or even revoked. Some examples include -\n\n* [Hashicorp Vault](https://www.vaultproject.io)\n* [AWS KMS](https://aws.amazon.com/kms) (Key Management Service)\n* [Google Cloud KMS](https://cloud.google.com/security-key-management)\n\n## Least-privilege principle\n\nStoring a secret in a hardcoded manner can be made safer, by making sure the secret grants the least amount of privilege as needed by the application.\nFor example - if the application needs to read a specific table from a specific database, and the secret grants access to perform this operation **only** (meaning - no access to other tables, no write access at all) then the damage from any secret leaks is mitigated.\nThat being said, it is still not recommended to store secrets in a hardcoded manner, since this type of storage does not offer any way to revoke or moderate the usage of the secret.\n"
              },
              "properties": {
                "applicability": "not_applicable",
                "conclusion": "positive"
              }
            },
            {
              "id": "REQ.SECRET.KEYS",
              "name": "REQ.SECRET.KEYS",
              "shortDescription": {
                "text": "Scanner for REQ.SECRET.KEYS"
              },
              "fullDescription": {
                "text": "\nStoring an API key in the image could lead to several risks.\n\nIf the key is associated with a wide scope of privileges, attackers could extract it from a single image or firmware and use it maliciously to attack many targets. For example, if the embedded key allows querying/modifying data for all cloud user accounts, without per-user authentication, the attackers who extract it would gain access to system-wide data.\n\nIf the cloud/SaaS provider bills by key usage - for example, every million queries cost the key's owner a fixed sum of money - attackers could use the keys for their own purposes (or just as a form of vandalism), incurring a large cost to the legitimate user or operator.\n\n## Best practices\n\nUse narrow scopes for stored API keys. As much as possible, API keys should be unique per host and require additional authentication with the user's individual credentials for any sensitive actions.\n\nAvoid placing keys whose use incurs costs directly in the image. Store the key with any software or hardware protection available on the host for key storage (such as operating system key-stores, hardware cryptographic storage mechanisms or cloud-managed secure storage services such as [AWS KMS](https://aws.amazon.com/kms/)).\n\nTokens that were detected as exposed should be revoked and replaced -\n\n* [AWS Key Revocation](https://aws.amazon.com/premiumsupport/knowledge-center/delete-access-key/#:~:text=If%20you%20see%20a%20warning,the%20confirmation%20box%2C%20choose%20Deactivate.)\n* [GCP Key Revocation](https://www.trendmicro.com/cloudoneconformity/knowledge-base/gcp/CloudIAM/delete-api-keys.html)\n* [Azure Key Revocation](https://docs.microsoft.com/en-us/azure/devops/organizations/accounts/use-personal-access-tokens-to-authenticate?view=azure-devops\u0026tabs=Windows#revoke-a-pat)\n* [GitHub Key Revocation](https://docs.github.com/en/rest/apps/oauth-applications#delete-an-app-authorization)\n",
                "markdown": "\nStoring an API key in the image could lead to several risks.\n\nIf the key is associated with a wide scope of privileges, attackers could extract it from a single image or firmware and use it maliciously to attack many targets. For example, if the embedded key allows querying/modifying data for all cloud user accounts, without per-user authentication, the attackers who extract it would gain access to system-wide data.\n\nIf the cloud/SaaS provider bills by key usage - for example, every million queries cost the key's owner a fixed sum of money - attackers could use the keys for their own purposes (or just as a form of vandalism), incurring a large cost to the legitimate user or operator.\n\n## Best practices\n\nUse narrow scopes for stored API keys. As much as possible, API keys should be unique per host and require additional authentication with the user's individual credentials for any sensitive actions.\n\nAvoid placing keys whose use incurs costs directly in the image. Store the key with any software or hardware protection available on the host for key storage (such as operating system key-stores, hardware cryptographic storage mechanisms or cloud-managed secure storage services such as [AWS KMS](https://aws.amazon.com/kms/)).\n\nTokens that were detected as exposed should be revoked and replaced -\n\n* [AWS Key Revocation](https://aws.amazon.com/premiumsupport/knowledge-center/delete-access-key/#:~:text=If%20you%20see%20a%20warning,the%20confirmation%20box%2C%20choose%20Deactivate.)\n* [GCP Key Revocation](https://www.trendmicro.com/cloudoneconformity/knowledge-base/gcp/CloudIAM/delete-api-keys.html)\n* [Azure Key Revocation](https://docs.microsoft.com/en-us/azure/devops/organizations/accounts/use-personal-access-tokens-to-authenticate?view=azure-devops\u0026tabs=Windows#revoke-a-pat)\n* [GitHub Key Revocation](https://docs.github.com/en/rest/apps/oauth-applications#delete-an-app-authorization)\n"
              },
              "properties": {
                "applicability": "undetermined",
                "conclusion": "private"
              }
            }
          ],
          "version": "1.0"
        }
      },
      "invocations": [
        {
          "arguments": [
            "/root/.jfrog/dependencies/analyzerManager/jas_scanner/jas_scanner",
            "scan",
            "/tmp/jfrog.cli.temp.-1718663484-2820551762/config.yaml"
          ],
          "executionSuccessful": true,
          "workingDirectory": {
            "uri": "/tmp/jfrog.cli.temp.-1718663408-3727193563/image.tar"
          }
        }
      ],
      "results": [
        {
          "ruleId": "REQ.SECRET.GENERIC.TEXT",
          "message": {
            "text": "Hardcoded secrets were found"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file:///tmp/tmpb99ly6yj/unpacked/filesystem/blobs/sha256/d65b7de3940e104e413cd75ef12950b52e9ed7ab260df1880b014b8d308b63ca/defaults/dns-conf/dnsmadeeasy.ini"
                },
                "region": {
                  "startLine": 3,
                  "startColumn": 0,
                  "endLine": 3,
                  "endColumn": 0,
                  "snippet": {
                    "text": "dns************"
                  }
                }
              }
            }
          ]
        },
        {
          "ruleId": "REQ.SECRET.GENERIC.TEXT",
          "message": {
            "text": "Hardcoded secrets were found"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file:///tmp/tmpb99ly6yj/unpacked/filesystem/blobs/sha256/d65b7de3940e104e413cd75ef12950b52e9ed7ab260df1880b014b8d308b63ca/defaults/dns-conf/dnsmadeeasy.ini"
                },
                "region": {
                  "startLine": 4,
                  "startColumn": 0,
                  "endLine": 4,
                  "endColumn": 0,
                  "snippet": {
                    "text": "dns************"
                  }
                }
              }
            }
          ]
        },
        {
          "ruleId": "REQ.SECRET.GENERIC.TEXT",
          "message": {
            "text": "Hardcoded secrets were found"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file:///tmp/tmpb99ly6yj/unpacked/filesystem/blobs/sha256/d65b7de3940e104e413cd75ef12950b52e9ed7ab260df1880b014b8d308b63ca/defaults/dns-conf/rfc2136.ini"
                },
                "region": {
                  "startLine": 8,
                  "startColumn": 0,
                  "endLine": 8,
                  "endColumn": 0,
                  "snippet": {
                    "text": "dns************"
                  }
                }
              }
            }
          ]
        }
      ]
    }
  ]
}
