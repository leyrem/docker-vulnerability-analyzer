package scanners

import (
	"context"
	"fmt"
	"log"
	"os/exec"
	"regexp"
	"strings"
	"sync"
	"time"

	"github.com/leyrem/docker-vulnerability-analyzer/docker"
	"github.com/leyrem/docker-vulnerability-analyzer/outputdata"
	"github.com/leyrem/docker-vulnerability-analyzer/sarif"
	"github.com/leyrem/docker-vulnerability-analyzer/utils"
)

var (
	TRIVY_SCANNER = &Scanner{
		Name:           "Trivy",
		Command:        []string{"trivy", "image"},
		OutputFileFlag: "-o",
		Flags: []CommandFlags{
			{Name: "-f", Value: "sarif"},
			{Name: "--scanners", Value: "vuln"},
		},
	}
	DOCKERSCOUT_SCANNER = &Scanner{
		Name:           "DockerScout",
		Command:        []string{"docker", "scout", "cves"},
		OutputFileFlag: "--output",
		Flags: []CommandFlags{
			{Name: "--format", Value: "sarif"},
			{Name: "--epss", Value: ""},
			{Name: "--details", Value: ""},
			{Name: "--locations", Value: ""},
		},
	}
	GRYPE_SCANNER = &Scanner{
		Name:           "Grype",
		Command:        []string{"grype"},
		OutputFileFlag: "--file",
		Flags: []CommandFlags{
			{Name: "-o", Value: "sarif"},
		},
	}
	SNYK_SCANNER = &Scanner{
		Name:           "Snyk",
		ImageFirst:     true,
		Command:        []string{"snyk", "container", "test"},
		OutputFileFlag: "--sarif-file-output=",
		Flags:          []CommandFlags{},
	} //jf docker scan --format=sarif --detailed-summary=true --extended-table=true fluent/fluent-bit:latest > jfrogdone.json

	JFROG_SCANNER = &Scanner{
		Name:           "JFrog",
		Command:        []string{"jf", "docker", "scan"},
		OutputFileFlag: ">",
		Flags: []CommandFlags{
			{Name: "--format=", Value: "sarif"},
			{Name: "--detailed-summary=", Value: "true"},
			{Name: "--extended-table=", Value: "true"},
		},
	}
)

type Scanner struct {
	ImageFirst     bool
	Name           string
	Command        []string
	OutputFileFlag string
	Flags          []CommandFlags
}

type CommandFlags struct {
	Name  string
	Value string
}

// checkPrerequisites makes sure all the prerequisites are satisfied before running the scan.
// The prerequisites include:
// - Docker Daemon is running
// - All the scanners are installed in the host system
// TODO: Add check for scanners installation
func checkPrerequisites(ctx context.Context) (*docker.Client, error) {
	cli, err := docker.CheckDockerStatus(ctx)
	if err != nil {
		return nil, err
	}
	return cli, nil
}

// CommandString constructs the command string from exec.Cmd
func commandString(cmd *exec.Cmd) string {
	// Combine the command and its arguments
	return strings.Join(append([]string{cmd.Path}, cmd.Args[1:]...), " ")
}

func (s *Scanner) executeCommandScanner(imageName string, outputFilepath string) error {

	name := s.Command[0]

	var args []string

	if len(s.Command) > 1 {
		// Iterate over the slice starting at index 1
		for _, str := range s.Command[1:] {
			args = append(args, str)
		}
	}

	if s.ImageFirst {
		args = append(args, imageName)
	}

	for _, f := range s.Flags {
		if strings.Contains(f.Name, "=") {
			args = append(args, f.Name+f.Value)
		} else {
			args = append(args, f.Name)
			if f.Value == "" {
				continue
			}
			args = append(args, f.Value)
		}
	}

	// Get the current timestamp
	currentTime := time.Now()
	timeString := currentTime.Format("2006-01-02_15:04:05")

	// Replace "/" with "="
	newStrImage := strings.Replace(imageName, "/", "=", -1)
	outputFileName := outputFilepath + "/" + s.Name + "_scan_" + newStrImage + "_" + timeString + ".json"

	if strings.Contains(s.OutputFileFlag, "=") {
		args = append(args, s.OutputFileFlag+outputFileName)
	} else if s.OutputFileFlag == ">" { //TODO: handle this properly
		args = append(args, imageName)
		args = append(args, s.OutputFileFlag)
		args = append(args, outputFileName)
	} else {
		args = append(args, s.OutputFileFlag)
		args = append(args, outputFileName)
	}

	if !s.ImageFirst && s.OutputFileFlag != ">" {
		args = append(args, imageName)
	}

	// Create the command with variadic arguments
	cmd := exec.Command(name, args...)

	if s.Name == "JFrog" { //TODO: handle this properly
		cmd = exec.Command("sh", "-c", "jf docker scan --format=sarif --detailed-summary=true --extended-table=true "+imageName+" > "+outputFileName)
	}

	// Get the command string
	cmdStr := commandString(cmd)

	// Execute the command and capture the output
	output, err := cmd.CombinedOutput()

	if err != nil {
		if exitErr, ok := err.(*exec.ExitError); ok { // The program has exited with a non-zero status
			if exitErr.ExitCode() == 1 && s.Name == "Snyk" {
				// This is not an actual error, but just means vulnerabilities were found
				log.Println("Snyk scan was succesful")
			} else {
				log.Printf("command [%s] execution failed: %v\nOutput: %s", cmdStr, err, string(output))
				return fmt.Errorf("command [%s] execution failed: %v\nOutput: %s", cmdStr, err, string(output))
			}
		} else {
			log.Printf("command [%s] execution failed: %v\nOutput: %s", cmdStr, err, string(output))
			return fmt.Errorf("command [%s] execution failed: %v\nOutput: %s", cmdStr, err, string(output))
		}
	}

	// Print the output
	log.Printf("Command [%s] executed successfully\n", cmdStr)
	log.Println("Output: ", string(output))
	return nil
}

// Execute scan executes the scan command of the corresponding scanner.
// First it pulls the docker image, then it executes the scan, and finally it deletes the docker image from the system.
func (s *Scanner) executeScan(ctx context.Context, wg *sync.WaitGroup, results chan<- error, image string, ouputFilepath string) {

	defer wg.Done()

	err := s.executeCommandScanner(image, ouputFilepath)

	if err != nil {
		err = fmt.Errorf("Error with scanner %s : %v", s.Name, err)
	}

	results <- err
}

func parseCVSSTrivy(rules []sarif.Rule) map[string]string {
	rulesCveMap := make(map[string]string)

	for _, rule := range rules {
		t := rule.FullDescription.Text
		sevScore := utils.ExtractCVSSFromStrTRIVY(t)
		rulesCveMap[rule.ID] = sevScore
	}
	return rulesCveMap
}

func parseLocationTrivy(locations []sarif.Location, fileName string) (string, error) {
	if len(locations) != 1 {
		return "", fmt.Errorf("error parsing locations for trivy scan file %s, locations length is: %d", fileName, len(locations))
	}
	return locations[0].Message.Text, nil
}

func parseLocationAndIdSynk(rules []sarif.Rule, fileName string) map[string][]string {
	rulesCveMap := make(map[string][]string)

	for _, rule := range rules {
		t := rule.FullDescription.Text

		// Define a regular expression pattern to match CVE identifiers
		re := regexp.MustCompile(`CVE-\d+-\d+`)

		// Find the first match in the string
		match := re.FindString(t)

		// Print the matched CVE
		if match == "" {
			log.Printf("in report file %s, no CVE was found for rule ID %s", fileName, rule.ID)
		} else {
			locationSynk := utils.ExtractComponentSnyk(t)
			score := rule.Properties.CVSS_V3_Severity

			sev := strings.Split(rule.ShortDescription.Text, " ")

			rulesCveMap[rule.ID] = []string{match, locationSynk, score, sev[0]}
		}

	}
	return rulesCveMap
}

func parseLocationDockerScout(rules []sarif.Rule) map[string][]string {
	rulesCveMap := make(map[string][]string)

	for _, rule := range rules {
		location := ""
		for _, purl := range rule.Properties.Purls {
			location = location + " " + purl
		}
		s := fmt.Sprintf("%f", rule.Properties.CvssV3) //DockerScout sometimes lists the CVSS score here
		rulesCveMap[rule.ID] = []string{location, rule.Properties.CVSS_V3_Severity, s}
	}
	return rulesCveMap
}

func parseCVSSJfrogGrype(rules []sarif.Rule) map[string]string {
	rulesCveMap := make(map[string]string)

	for _, rule := range rules {
		rulesCveMap[rule.ID] = rule.Properties.SecuritySeverity
	}
	return rulesCveMap
}

func analyseSnykResults(runs []sarif.Run, fileName string) []outputdata.CVE {

	listCVEs := []outputdata.CVE{}

	for _, run := range runs {
		if len(run.Results) == 0 {
			continue
		}

		var rulesCveMapSynk map[string][]string

		rulesCveMapSynk = parseLocationAndIdSynk(run.Tool.Driver.Rules, fileName)

		for _, res := range run.Results {
			if _, ok := rulesCveMapSynk[res.RuleID]; !ok {
				//Key not in  map
				continue
			}
			currentCVE := outputdata.CVE{
				CVE_ID:       rulesCveMapSynk[res.RuleID][0],
				Packages:     []string{rulesCveMapSynk[res.RuleID][1]},
				CVSSV3_Score: rulesCveMapSynk[res.RuleID][2],
				Severity:     rulesCveMapSynk[res.RuleID][3],
			}
			listCVEs = append(listCVEs, currentCVE)
		}

	}
	return listCVEs
}

// GetListCVEs gets the list of CVEs detected by the current scanner in the report file specified as input.
func (s *Scanner) GetListCVEs(wg *sync.WaitGroup, resultsErr chan<- error, resultsData chan<- *outputdata.GetListCVEsAllScannersRes, fileName string) {

	defer wg.Done()

	sarifData, err := sarif.Parse(fileName)

	if err != nil {
		resultsData <- &outputdata.GetListCVEsAllScannersRes{}
		resultsErr <- fmt.Errorf("error parsing sarif file report %s: %v", fileName, err)
		return
	}

	if len(sarifData.Runs) == 0 {
		resultsData <- &outputdata.GetListCVEsAllScannersRes{}
		resultsErr <- fmt.Errorf("image report file %s has no RUNS field", fileName)
		return
	}

	if len(sarifData.Runs) != 1 {
		// In the  case of JFrog, runs are always length 3 and the first  one is the one about CVEs
		// In the  case of Snyk, sometimes runs length is  more than 1, it  seems results are just divided and we  have to  analyse  all runs.
		log.Printf("WARN!!!!! - Length of runs for file %s is %d\n", fileName, len(sarifData.Runs))
	}

	listCVEs := []outputdata.CVE{}

	var rulesCveMapDS map[string][]string
	var rulesCveMapJF map[string]string
	var rulesCveMapTrivy map[string]string

	if s.Name == "DockerScout" {
		rulesCveMapDS = parseLocationDockerScout(sarifData.Runs[0].Tool.Driver.Rules)
	}
	if s.Name == "JFrog" || s.Name == "Grype" {
		rulesCveMapJF = parseCVSSJfrogGrype(sarifData.Runs[0].Tool.Driver.Rules)
	}
	if s.Name == "Trivy" {
		rulesCveMapTrivy = parseCVSSTrivy(sarifData.Runs[0].Tool.Driver.Rules)
	}
	if s.Name == "Snyk" {
		listSnk := analyseSnykResults(sarifData.Runs, fileName)
		listCVEs = append(listCVEs, listSnk...)
	}

	for _, res := range sarifData.Runs[0].Results {

		currentCVE := outputdata.CVE{}

		switch s.Name {
		case "Trivy":
			currentCVE.CVE_ID = res.RuleID

			location, err := parseLocationTrivy(res.Locations, fileName)
			if err != nil {
				resultsData <- &outputdata.GetListCVEsAllScannersRes{}
				resultsErr <- err
				return
			}
			currentCVE.Packages = append(currentCVE.Packages, location)

			sev := utils.ExtractSeverityValueTrivy(res.Message.Text)
			currentCVE.Severity = sev
			currentCVE.CVSSV3_Score = rulesCveMapTrivy[res.RuleID] // Only available sometimes

		case "DockerScout":
			currentCVE.CVE_ID = res.RuleID
			currentCVE.Packages = append(currentCVE.Packages, rulesCveMapDS[res.RuleID][0])
			currentCVE.Severity = rulesCveMapDS[res.RuleID][1]
			currentCVE.CVSSV3_Score = rulesCveMapDS[res.RuleID][2]
			// cvssv3 score not  always available

		case "Grype": // Pkg name contained in rule ID
			_, after := utils.SplitByThirdHyphen(res.RuleID)
			sev := strings.Split(res.Message.Text, " ")

			cve_id := utils.ExtractCVEIDFromStr(res.RuleID)
			currentCVE.CVE_ID = cve_id
			currentCVE.Severity = sev[1]
			currentCVE.Packages = append(currentCVE.Packages, after)
			currentCVE.CVSSV3_Score = rulesCveMapJF[res.RuleID]

		case "JFrog": // Pkg name contained in rule ID

			currentCVE.CVE_ID = utils.ExtractCVEIDFromStr(res.RuleID)

			// Find the index of the first occurrence of '_'
			index := strings.Index(res.RuleID, "_")
			if index == -1 {
				log.Printf("cannot find pkg name for filename %s in JFrog analyis for rule ID %s", fileName, res.RuleID)
			} else {
				// Split the string at the index
				after := res.RuleID[index+1:]
				currentCVE.Packages = append(currentCVE.Packages, after)
			}
			currentCVE.CVSSV3_Score = rulesCveMapJF[res.RuleID]
			//TODO: no severity as in LOW, HIGH,....

		}
		listCVEs = append(listCVEs, currentCVE)
	}

	a := &outputdata.GetListCVEsAllScannersRes{
		ScannerName: s.Name,
		CVEs:        listCVEs,
		NumCVEs:     len(listCVEs),
	}

	dups, listCVEs := utils.HasDuplicates(listCVEs)
	if len(dups) > 0 {
		a.HasDuplicatesCVE_IDs = true
		a.DuplicatesList = dups
		a.CVEs = listCVEs
		a.NumCVEs = len(listCVEs)
	}

	resultsData <- a
	resultsErr <- err
}

func instantiateAllScanners() []*Scanner {
	return []*Scanner{TRIVY_SCANNER, GRYPE_SCANNER, JFROG_SCANNER, DOCKERSCOUT_SCANNER, SNYK_SCANNER}
	//return []*Scanner{JFROG_SCANNER}
}

func InstantiateGivenScanners(scannersToUse []string) []*Scanner {
	res := []*Scanner{}

	for _, scannerName := range scannersToUse {
		switch scannerName {
		case "JFrog":
			res = append(res, JFROG_SCANNER)
		case "Trivy":
			res = append(res, TRIVY_SCANNER)
		case "Grype":
			res = append(res, GRYPE_SCANNER)
		case "DockerScout":
			res = append(res, DOCKERSCOUT_SCANNER)
		case "Snyk":
			res = append(res, SNYK_SCANNER)
		default:
			log.Printf("Scanner %s specified is not available to use \n", scannerName)
		}
	}
	return res
}

func UseGivenScanners(scannersToUse []string, imageName string, outputFilepath string) error {

	ctx := context.Background()
	cli, err := checkPrerequisites(ctx)
	if err != nil {
		return err
	}
	scanners := InstantiateGivenScanners(scannersToUse)

	if len(scanners) == 0 {
		return fmt.Errorf("no scanners were specified to be used")
	}

	err = cli.PullImage(ctx, imageName)
	if err != nil {
		return err
	}

	workersCount := len(scanners)
	var wg sync.WaitGroup
	wg.Add(workersCount)
	results := make(chan error, workersCount)

	for _, scanner := range scanners {
		go scanner.executeScan(ctx, &wg, results, imageName, outputFilepath)
	}

	// Wait for all scanners to finish
	go func() {
		wg.Wait()
		close(results)
	}()

	var finalErr error

	// Process results
	for result := range results {
		if result != nil {
			finalErr = fmt.Errorf("%v \n NEW ERROR: %v", finalErr, result)
		}
	}

	err = cli.RemoveImage(ctx, imageName)
	return err
}

func UseAllScanners(imageName string, outputFilepath string) error {

	ctx := context.Background()
	cli, err := checkPrerequisites(ctx)
	if err != nil {
		return err
	}
	scanners := instantiateAllScanners()

	err = cli.PullImage(ctx, imageName)
	if err != nil {
		return err
	}

	workersCount := len(scanners)
	var wg sync.WaitGroup
	wg.Add(workersCount)
	results := make(chan error, workersCount)

	for _, scanner := range scanners {
		go scanner.executeScan(ctx, &wg, results, imageName, outputFilepath)
	}

	// Wait for all scanners to finish
	go func() {
		wg.Wait()
		close(results)
	}()

	var finalErr error

	// Process results
	for result := range results {
		if result != nil {
			finalErr = fmt.Errorf("%v \n NEW ERROR: %v", finalErr, result)
		}
	}

	err = cli.RemoveImage(ctx, imageName)
	return err
}
