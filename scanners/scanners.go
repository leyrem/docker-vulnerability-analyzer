package scanners

import (
	"context"
	"fmt"
	"log"
	"os/exec"
	"strings"
	"sync"
	"time"

	"github.com/leyrem/docker-vulnerability-analyzer/docker"
)

type Scanner struct {
	ImageFirst     bool
	Name           string
	Command        []string
	OutputFileFlag string
	Flags          []CommandFlags
	DockerClient   *docker.Client
}

type CommandFlags struct {
	Name  string
	Value string
}

// checkPrerequisites makes sure all the prerequisites are satisfied before running the scan.
// The prerequisites include:
// - Docker Daemon is running
// - All the scanners are installed in the host system
// TODO: Add check for scanners installation
func checkPrerequisites(ctx context.Context) (*docker.Client, error) {
	cli, err := docker.CheckDockerStatus(ctx)
	if err != nil {
		return nil, err
	}
	return cli, nil
}

// CommandString constructs the command string from exec.Cmd
func commandString(cmd *exec.Cmd) string {
	// Combine the command and its arguments
	return strings.Join(append([]string{cmd.Path}, cmd.Args[1:]...), " ")
}

func (s *Scanner) executeCommandScanner(imageName string, outputFilepath string) error {

	name := s.Command[0]

	var args []string

	if len(s.Command) > 1 {
		// Iterate over the slice starting at index 1
		for _, str := range s.Command[1:] {
			args = append(args, str)
		}
	}

	if s.ImageFirst {
		args = append(args, imageName)
	}

	for _, f := range s.Flags {
		args = append(args, f.Name)
		if f.Value == "" {
			continue
		}
		args = append(args, f.Value)
	}

	// Get the current timestamp
	currentTime := time.Now()
	timeString := currentTime.Format("2006-01-02_15:04:05")

	// Replace "/" with "="
	newStrImage := strings.Replace(imageName, "/", "=", -1)
	outputFileName := outputFilepath + "/" + s.Name + "_scan_" + newStrImage + "_" + timeString + ".json"

	if strings.Contains(s.OutputFileFlag, "=") {
		args = append(args, s.OutputFileFlag+outputFileName)
	} else {
		args = append(args, s.OutputFileFlag)
		args = append(args, outputFileName)
	}

	if !s.ImageFirst {
		args = append(args, imageName)
	}

	// Create the command with variadic arguments
	cmd := exec.Command(name, args...)

	// Get the command string
	cmdStr := commandString(cmd)

	// Execute the command and capture the output
	output, err := cmd.CombinedOutput()

	if err != nil {
		if exitErr, ok := err.(*exec.ExitError); ok { // The program has exited with a non-zero status
			if exitErr.ExitCode() == 1 && s.Name == "Snyk" {
				// This is not an actual error, but just means vulnerabilities were found
				log.Println("Snyk scan was succesful")
			} else {
				log.Printf("Command [%s] execution failed: %v\nOutput: %s", cmdStr, err, string(output))
				return fmt.Errorf("Command [%s] execution failed: %v\nOutput: %s", cmdStr, err, string(output))
			}
		} else {
			log.Printf("Command [%s] execution failed: %v\nOutput: %s", cmdStr, err, string(output))
			return fmt.Errorf("Command [%s] execution failed: %v\nOutput: %s", cmdStr, err, string(output))
		}
	}

	// Print the output
	log.Printf("Command [%s] executed successfully\n", cmdStr)
	log.Println("Output: ", string(output))
	return nil
}

// Execute scan executes the scan command of the corresponding scanner.
// First it pulls the docker image, then it executes the scan, and finally it deletes the docker image from the system.
func (s *Scanner) executeScan(ctx context.Context, wg *sync.WaitGroup, results chan<- error, image string, ouputFilepath string) {

	defer wg.Done()

	err := s.executeCommandScanner(image, ouputFilepath)

	err2 := fmt.Errorf("[---ERROR WITH SCANNER---" + s.Name + "]")

	err = fmt.Errorf("%v --->> %v", err2, err)

	results <- err
	return

}

func instantiateScanners(dockerClient *docker.Client) []*Scanner {
	return []*Scanner{
		{
			Name:           "Trivy",
			Command:        []string{"trivy", "image"},
			OutputFileFlag: "-o",
			Flags: []CommandFlags{
				{Name: "-f", Value: "sarif"},
				{Name: "--scanners", Value: "vuln"},
			},
			DockerClient: dockerClient,
		},
		{
			Name:           "DockerScout",
			Command:        []string{"docker", "scout", "cves"},
			OutputFileFlag: "--output",
			Flags: []CommandFlags{
				{Name: "--format", Value: "sarif"},
				{Name: "--epss", Value: ""},
				{Name: "--details", Value: ""},
				{Name: "--locations", Value: ""},
			},
			DockerClient: dockerClient,
		},
		{
			Name:           "Grype",
			Command:        []string{"grype"},
			OutputFileFlag: "--file",
			Flags: []CommandFlags{
				{Name: "-o", Value: "sarif"},
			},
			DockerClient: dockerClient,
		},
		{
			Name:           "Snyk",
			ImageFirst:     true,
			Command:        []string{"snyk", "container", "test"},
			OutputFileFlag: "--sarif-file-output=",
			Flags:          []CommandFlags{},
			DockerClient:   dockerClient,
		},
		/*{
			Name: "Clair",
			Command: "snyk container test",
			OutputFile: "",
			Flags: []CommandFlags{
				{Name: "--sarif-file-output=", Value: OutputFile},
			},
		},
		{
			Name: "JFrog",
			Command: "snyk container test",
			OutputFile: "",
			Flags: []CommandFlags{
				{Name: "--sarif-file-output=", Value: OutputFile},
			},
		},*/
	}

}

func UseAllScanners(imageName string, outputFilepath string) error {

	ctx := context.Background()
	cli, err := checkPrerequisites(ctx)
	if err != nil {
		return err
	}
	scanners := instantiateScanners(cli)

	err = scanners[0].DockerClient.PullImage(ctx, imageName)
	if err != nil {
		return err
	}

	workersCount := len(scanners)
	var wg sync.WaitGroup
	wg.Add(workersCount)
	results := make(chan error, workersCount)

	for _, scanner := range scanners {
		go scanner.executeScan(ctx, &wg, results, imageName, outputFilepath)
	}

	// Wait for all scanners to finish
	go func() {
		wg.Wait()
		close(results)
	}()

	// Process results
	for result := range results {
		if result != nil {
			//return result // Return the first non-nil error encountered
			return fmt.Errorf("error in scan: %v\n", result)
		}
	}

	err = scanners[0].DockerClient.RemoveImage(ctx, imageName)
	return nil
}
