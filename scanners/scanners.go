package scanners

import (
	"context"
	"fmt"
	"log"
	"os/exec"
	"strings"
	"sync"
	"time"

	"github.com/leyrem/docker-vulnerability-analyzer/docker"
)

var (
	TRIVY_SCANNER = &Scanner{
		Name:           "Trivy",
		Command:        []string{"trivy", "image"},
		OutputFileFlag: "-o",
		Flags: []CommandFlags{
			{Name: "-f", Value: "sarif"},
			{Name: "--scanners", Value: "vuln"},
		},
	}
	DOCKERSCOUT_SCANNER = &Scanner{
		Name:           "DockerScout",
		Command:        []string{"docker", "scout", "cves"},
		OutputFileFlag: "--output",
		Flags: []CommandFlags{
			{Name: "--format", Value: "sarif"},
			{Name: "--epss", Value: ""},
			{Name: "--details", Value: ""},
			{Name: "--locations", Value: ""},
		},
	}
	GRYPE_SCANNER = &Scanner{
		Name:           "Grype",
		Command:        []string{"grype"},
		OutputFileFlag: "--file",
		Flags: []CommandFlags{
			{Name: "-o", Value: "sarif"},
		},
	}
	SNYK_SCANNER = &Scanner{
		Name:           "Snyk",
		ImageFirst:     true,
		Command:        []string{"snyk", "container", "test"},
		OutputFileFlag: "--sarif-file-output=",
		Flags:          []CommandFlags{},
	} //jf docker scan --format=sarif --detailed-summary=true --extended-table=true fluent/fluent-bit:latest > jfrogdone.json

	JFROG_SCANNER = &Scanner{
		Name:           "JFrog",
		Command:        []string{"jf", "docker", "scan"},
		OutputFileFlag: ">",
		Flags: []CommandFlags{
			{Name: "--format=", Value: "sarif"},
			{Name: "--detailed-summary=", Value: "true"},
			{Name: "--extended-table=", Value: "true"},
		},
	}
)

type Scanner struct {
	ImageFirst     bool
	Name           string
	Command        []string
	OutputFileFlag string
	Flags          []CommandFlags
}

type CommandFlags struct {
	Name  string
	Value string
}

// checkPrerequisites makes sure all the prerequisites are satisfied before running the scan.
// The prerequisites include:
// - Docker Daemon is running
// - All the scanners are installed in the host system
// TODO: Add check for scanners installation
func checkPrerequisites(ctx context.Context) (*docker.Client, error) {
	cli, err := docker.CheckDockerStatus(ctx)
	if err != nil {
		return nil, err
	}
	return cli, nil
}

// CommandString constructs the command string from exec.Cmd
func commandString(cmd *exec.Cmd) string {
	// Combine the command and its arguments
	return strings.Join(append([]string{cmd.Path}, cmd.Args[1:]...), " ")
}

func (s *Scanner) executeCommandScanner(imageName string, outputFilepath string) error {

	name := s.Command[0]

	var args []string

	if len(s.Command) > 1 {
		// Iterate over the slice starting at index 1
		for _, str := range s.Command[1:] {
			args = append(args, str)
		}
	}

	if s.ImageFirst {
		args = append(args, imageName)
	}

	for _, f := range s.Flags {
		if strings.Contains(f.Name, "=") {
			args = append(args, f.Name+f.Value)
		} else {
			args = append(args, f.Name)
			if f.Value == "" {
				continue
			}
			args = append(args, f.Value)
		}
	}

	// Get the current timestamp
	currentTime := time.Now()
	timeString := currentTime.Format("2006-01-02_15:04:05")

	// Replace "/" with "="
	newStrImage := strings.Replace(imageName, "/", "=", -1)
	outputFileName := outputFilepath + "/" + s.Name + "_scan_" + newStrImage + "_" + timeString + ".json"

	if strings.Contains(s.OutputFileFlag, "=") {
		args = append(args, s.OutputFileFlag+outputFileName)
	} else if s.OutputFileFlag == ">" { //TODO: handle this properly
		args = append(args, imageName)
		args = append(args, s.OutputFileFlag)
		args = append(args, outputFileName)
	} else {
		args = append(args, s.OutputFileFlag)
		args = append(args, outputFileName)
	}

	if !s.ImageFirst && s.OutputFileFlag != ">" {
		args = append(args, imageName)
	}

	// Create the command with variadic arguments
	cmd := exec.Command(name, args...)

	if s.Name == "JFrog" { //TODO: handle this properly
		cmd = exec.Command("sh", "-c", "jf docker scan --format=sarif --detailed-summary=true --extended-table=true "+imageName+" > "+outputFileName)
	}

	// Get the command string
	cmdStr := commandString(cmd)

	// Execute the command and capture the output
	output, err := cmd.CombinedOutput()

	if err != nil {
		if exitErr, ok := err.(*exec.ExitError); ok { // The program has exited with a non-zero status
			if exitErr.ExitCode() == 1 && s.Name == "Snyk" {
				// This is not an actual error, but just means vulnerabilities were found
				log.Println("Snyk scan was succesful")
			} else {
				log.Printf("command [%s] execution failed: %v\nOutput: %s", cmdStr, err, string(output))
				return fmt.Errorf("command [%s] execution failed: %v\nOutput: %s", cmdStr, err, string(output))
			}
		} else {
			log.Printf("command [%s] execution failed: %v\nOutput: %s", cmdStr, err, string(output))
			return fmt.Errorf("command [%s] execution failed: %v\nOutput: %s", cmdStr, err, string(output))
		}
	}

	// Print the output
	log.Printf("Command [%s] executed successfully\n", cmdStr)
	log.Println("Output: ", string(output))
	return nil
}

// Execute scan executes the scan command of the corresponding scanner.
// First it pulls the docker image, then it executes the scan, and finally it deletes the docker image from the system.
func (s *Scanner) executeScan(ctx context.Context, wg *sync.WaitGroup, results chan<- error, image string, ouputFilepath string) {

	defer wg.Done()

	err := s.executeCommandScanner(image, ouputFilepath)

	if err != nil {
		err2 := fmt.Errorf("[---ERROR WITH SCANNER---" + s.Name + "]")
		err = fmt.Errorf("%v --->> %v", err2, err)
	}

	results <- err
}

func instantiateAllScanners() []*Scanner {
	//return []*Scanner{TRIVY_SCANNER, GRYPE_SCANNER, JFROG_SCANNER, DOCKERSCOUT_SCANNER, SNYK_SCANNER}
	return []*Scanner{JFROG_SCANNER}
}

func instantiateGivenScanners(scannersToUse []string) []*Scanner {
	res := []*Scanner{}

	for _, scannerName := range scannersToUse {
		switch scannerName {
		case "JFrog":
			res = append(res, JFROG_SCANNER)
		case "Trivy":
			res = append(res, TRIVY_SCANNER)
		case "Grype":
			res = append(res, GRYPE_SCANNER)
		case "DockerScout":
			res = append(res, DOCKERSCOUT_SCANNER)
		case "Snyk":
			res = append(res, SNYK_SCANNER)
		default:
			log.Println("Scanner %s specified is not available to use \n", scannerName)
		}
	}
	return res
}

func UseGivenScanners(scannersToUse []string, imageName string, outputFilepath string) error {

	ctx := context.Background()
	cli, err := checkPrerequisites(ctx)
	if err != nil {
		return err
	}
	scanners := instantiateGivenScanners(scannersToUse)

	if len(scanners) == 0 {
		return fmt.Errorf("no scanners were specified to be used")
	}

	err = cli.PullImage(ctx, imageName)
	if err != nil {
		return err
	}

	workersCount := len(scanners)
	var wg sync.WaitGroup
	wg.Add(workersCount)
	results := make(chan error, workersCount)

	for _, scanner := range scanners {
		go scanner.executeScan(ctx, &wg, results, imageName, outputFilepath)
	}

	// Wait for all scanners to finish
	go func() {
		wg.Wait()
		close(results)
	}()

	var finalErr error

	// Process results
	for result := range results {
		if result != nil {
			finalErr = fmt.Errorf("%v \n NEW ERROR: %v", finalErr, result)
		}
	}

	err = cli.RemoveImage(ctx, imageName)
	return err
}

func UseAllScanners(imageName string, outputFilepath string) error {

	ctx := context.Background()
	cli, err := checkPrerequisites(ctx)
	if err != nil {
		return err
	}
	scanners := instantiateAllScanners()

	err = cli.PullImage(ctx, imageName)
	if err != nil {
		return err
	}

	workersCount := len(scanners)
	var wg sync.WaitGroup
	wg.Add(workersCount)
	results := make(chan error, workersCount)

	for _, scanner := range scanners {
		go scanner.executeScan(ctx, &wg, results, imageName, outputFilepath)
	}

	// Wait for all scanners to finish
	go func() {
		wg.Wait()
		close(results)
	}()

	var finalErr error

	// Process results
	for result := range results {
		if result != nil {
			finalErr = fmt.Errorf("%v \n NEW ERROR: %v", finalErr, result)
		}
	}

	err = cli.RemoveImage(ctx, imageName)
	return err
}
